// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kubemq_go.proto

package kubemq

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StreamRequestType int32

const (
	StreamRequestType_StreamRequestTypeUnknown StreamRequestType = 0
	StreamRequestType_ReceiveMessage           StreamRequestType = 1
	StreamRequestType_AckMessage               StreamRequestType = 2
	StreamRequestType_RejectMessage            StreamRequestType = 3
	StreamRequestType_ModifyVisibility         StreamRequestType = 4
	StreamRequestType_ResendMessage            StreamRequestType = 5
	StreamRequestType_SendModifiedMessage      StreamRequestType = 6
)

var StreamRequestType_name = map[int32]string{
	0: "StreamRequestTypeUnknown",
	1: "ReceiveMessage",
	2: "AckMessage",
	3: "RejectMessage",
	4: "ModifyVisibility",
	5: "ResendMessage",
	6: "SendModifiedMessage",
}

var StreamRequestType_value = map[string]int32{
	"StreamRequestTypeUnknown": 0,
	"ReceiveMessage":           1,
	"AckMessage":               2,
	"RejectMessage":            3,
	"ModifyVisibility":         4,
	"ResendMessage":            5,
	"SendModifiedMessage":      6,
}

func (x StreamRequestType) String() string {
	return proto.EnumName(StreamRequestType_name, int32(x))
}

func (StreamRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{0}
}

type QueuesDownstreamRequestType int32

const (
	QueuesDownstreamRequestType_PollRequestTypeUnknown QueuesDownstreamRequestType = 0
	QueuesDownstreamRequestType_Get                    QueuesDownstreamRequestType = 1
	QueuesDownstreamRequestType_AckAll                 QueuesDownstreamRequestType = 2
	QueuesDownstreamRequestType_AckRange               QueuesDownstreamRequestType = 3
	QueuesDownstreamRequestType_NAckAll                QueuesDownstreamRequestType = 4
	QueuesDownstreamRequestType_NAckRange              QueuesDownstreamRequestType = 5
	QueuesDownstreamRequestType_ReQueueAll             QueuesDownstreamRequestType = 6
	QueuesDownstreamRequestType_ReQueueRange           QueuesDownstreamRequestType = 7
	QueuesDownstreamRequestType_CloseByClient          QueuesDownstreamRequestType = 8
	QueuesDownstreamRequestType_CloseByServer          QueuesDownstreamRequestType = 9
)

var QueuesDownstreamRequestType_name = map[int32]string{
	0: "PollRequestTypeUnknown",
	1: "Get",
	2: "AckAll",
	3: "AckRange",
	4: "NAckAll",
	5: "NAckRange",
	6: "ReQueueAll",
	7: "ReQueueRange",
	8: "CloseByClient",
	9: "CloseByServer",
}

var QueuesDownstreamRequestType_value = map[string]int32{
	"PollRequestTypeUnknown": 0,
	"Get":                    1,
	"AckAll":                 2,
	"AckRange":               3,
	"NAckAll":                4,
	"NAckRange":              5,
	"ReQueueAll":             6,
	"ReQueueRange":           7,
	"CloseByClient":          8,
	"CloseByServer":          9,
}

func (x QueuesDownstreamRequestType) String() string {
	return proto.EnumName(QueuesDownstreamRequestType_name, int32(x))
}

func (QueuesDownstreamRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{1}
}

type Subscribe_SubscribeType int32

const (
	Subscribe_SubscribeTypeUndefined Subscribe_SubscribeType = 0
	Subscribe_Events                 Subscribe_SubscribeType = 1
	Subscribe_EventsStore            Subscribe_SubscribeType = 2
	Subscribe_Commands               Subscribe_SubscribeType = 3
	Subscribe_Queries                Subscribe_SubscribeType = 4
)

var Subscribe_SubscribeType_name = map[int32]string{
	0: "SubscribeTypeUndefined",
	1: "Events",
	2: "EventsStore",
	3: "Commands",
	4: "Queries",
}

var Subscribe_SubscribeType_value = map[string]int32{
	"SubscribeTypeUndefined": 0,
	"Events":                 1,
	"EventsStore":            2,
	"Commands":               3,
	"Queries":                4,
}

func (x Subscribe_SubscribeType) String() string {
	return proto.EnumName(Subscribe_SubscribeType_name, int32(x))
}

func (Subscribe_SubscribeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{5, 0}
}

type Subscribe_EventsStoreType int32

const (
	Subscribe_EventsStoreTypeUndefined Subscribe_EventsStoreType = 0
	Subscribe_StartNewOnly             Subscribe_EventsStoreType = 1
	Subscribe_StartFromFirst           Subscribe_EventsStoreType = 2
	Subscribe_StartFromLast            Subscribe_EventsStoreType = 3
	Subscribe_StartAtSequence          Subscribe_EventsStoreType = 4
	Subscribe_StartAtTime              Subscribe_EventsStoreType = 5
	Subscribe_StartAtTimeDelta         Subscribe_EventsStoreType = 6
)

var Subscribe_EventsStoreType_name = map[int32]string{
	0: "EventsStoreTypeUndefined",
	1: "StartNewOnly",
	2: "StartFromFirst",
	3: "StartFromLast",
	4: "StartAtSequence",
	5: "StartAtTime",
	6: "StartAtTimeDelta",
}

var Subscribe_EventsStoreType_value = map[string]int32{
	"EventsStoreTypeUndefined": 0,
	"StartNewOnly":             1,
	"StartFromFirst":           2,
	"StartFromLast":            3,
	"StartAtSequence":          4,
	"StartAtTime":              5,
	"StartAtTimeDelta":         6,
}

func (x Subscribe_EventsStoreType) String() string {
	return proto.EnumName(Subscribe_EventsStoreType_name, int32(x))
}

func (Subscribe_EventsStoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{5, 1}
}

type Request_RequestType int32

const (
	Request_RequestTypeUnknown Request_RequestType = 0
	Request_Command            Request_RequestType = 1
	Request_Query              Request_RequestType = 2
)

var Request_RequestType_name = map[int32]string{
	0: "RequestTypeUnknown",
	1: "Command",
	2: "Query",
}

var Request_RequestType_value = map[string]int32{
	"RequestTypeUnknown": 0,
	"Command":            1,
	"Query":              2,
}

func (x Request_RequestType) String() string {
	return proto.EnumName(Request_RequestType_name, int32(x))
}

func (Request_RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{6, 0}
}

type PingResult struct {
	Host                 string   `protobuf:"bytes,1,opt,name=Host,proto3" json:"Host,omitempty"`
	Version              string   `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	ServerStartTime      int64    `protobuf:"varint,3,opt,name=ServerStartTime,proto3" json:"ServerStartTime,omitempty"`
	ServerUpTimeSeconds  int64    `protobuf:"varint,4,opt,name=ServerUpTimeSeconds,proto3" json:"ServerUpTimeSeconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingResult) Reset()      { *m = PingResult{} }
func (*PingResult) ProtoMessage() {}
func (*PingResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{0}
}
func (m *PingResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingResult.Merge(m, src)
}
func (m *PingResult) XXX_Size() int {
	return m.Size()
}
func (m *PingResult) XXX_DiscardUnknown() {
	xxx_messageInfo_PingResult.DiscardUnknown(m)
}

var xxx_messageInfo_PingResult proto.InternalMessageInfo

func (m *PingResult) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *PingResult) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *PingResult) GetServerStartTime() int64 {
	if m != nil {
		return m.ServerStartTime
	}
	return 0
}

func (m *PingResult) GetServerUpTimeSeconds() int64 {
	if m != nil {
		return m.ServerUpTimeSeconds
	}
	return 0
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{1}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Result struct {
	EventID              string   `protobuf:"bytes,1,opt,name=EventID,proto3" json:"EventID,omitempty"`
	Sent                 bool     `protobuf:"varint,2,opt,name=Sent,proto3" json:"Sent,omitempty"`
	Error                string   `protobuf:"bytes,3,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Result) Reset()      { *m = Result{} }
func (*Result) ProtoMessage() {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{2}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *Result) GetSent() bool {
	if m != nil {
		return m.Sent
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Event struct {
	EventID              string            `protobuf:"bytes,1,opt,name=EventID,proto3" json:"EventID,omitempty"`
	ClientID             string            `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string            `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string            `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte            `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	Store                bool              `protobuf:"varint,6,opt,name=Store,proto3" json:"Store,omitempty"`
	Tags                 map[string]string `protobuf:"bytes,7,rep,name=Tags,proto3" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Event) Reset()      { *m = Event{} }
func (*Event) ProtoMessage() {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{3}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *Event) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Event) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Event) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Event) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Event) GetStore() bool {
	if m != nil {
		return m.Store
	}
	return false
}

func (m *Event) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type EventReceive struct {
	EventID              string            `protobuf:"bytes,1,opt,name=EventID,proto3" json:"EventID,omitempty"`
	Channel              string            `protobuf:"bytes,2,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string            `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte            `protobuf:"bytes,4,opt,name=Body,proto3" json:"Body,omitempty"`
	Timestamp            int64             `protobuf:"varint,5,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Sequence             uint64            `protobuf:"varint,6,opt,name=Sequence,proto3" json:"Sequence,omitempty"`
	Tags                 map[string]string `protobuf:"bytes,7,rep,name=Tags,proto3" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EventReceive) Reset()      { *m = EventReceive{} }
func (*EventReceive) ProtoMessage() {}
func (*EventReceive) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{4}
}
func (m *EventReceive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReceive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReceive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReceive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReceive.Merge(m, src)
}
func (m *EventReceive) XXX_Size() int {
	return m.Size()
}
func (m *EventReceive) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReceive.DiscardUnknown(m)
}

var xxx_messageInfo_EventReceive proto.InternalMessageInfo

func (m *EventReceive) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *EventReceive) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *EventReceive) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *EventReceive) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *EventReceive) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EventReceive) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *EventReceive) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Subscribe struct {
	SubscribeTypeData    Subscribe_SubscribeType   `protobuf:"varint,1,opt,name=SubscribeTypeData,proto3,enum=kubemq.Subscribe_SubscribeType" json:"SubscribeTypeData,omitempty"`
	ClientID             string                    `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string                    `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Group                string                    `protobuf:"bytes,4,opt,name=Group,proto3" json:"Group,omitempty"`
	EventsStoreTypeData  Subscribe_EventsStoreType `protobuf:"varint,5,opt,name=EventsStoreTypeData,proto3,enum=kubemq.Subscribe_EventsStoreType" json:"EventsStoreTypeData,omitempty"`
	EventsStoreTypeValue int64                     `protobuf:"varint,6,opt,name=EventsStoreTypeValue,proto3" json:"EventsStoreTypeValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *Subscribe) Reset()      { *m = Subscribe{} }
func (*Subscribe) ProtoMessage() {}
func (*Subscribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{5}
}
func (m *Subscribe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subscribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subscribe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subscribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscribe.Merge(m, src)
}
func (m *Subscribe) XXX_Size() int {
	return m.Size()
}
func (m *Subscribe) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscribe.DiscardUnknown(m)
}

var xxx_messageInfo_Subscribe proto.InternalMessageInfo

func (m *Subscribe) GetSubscribeTypeData() Subscribe_SubscribeType {
	if m != nil {
		return m.SubscribeTypeData
	}
	return Subscribe_SubscribeTypeUndefined
}

func (m *Subscribe) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Subscribe) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Subscribe) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Subscribe) GetEventsStoreTypeData() Subscribe_EventsStoreType {
	if m != nil {
		return m.EventsStoreTypeData
	}
	return Subscribe_EventsStoreTypeUndefined
}

func (m *Subscribe) GetEventsStoreTypeValue() int64 {
	if m != nil {
		return m.EventsStoreTypeValue
	}
	return 0
}

type Request struct {
	RequestID            string              `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	RequestTypeData      Request_RequestType `protobuf:"varint,2,opt,name=RequestTypeData,proto3,enum=kubemq.Request_RequestType" json:"RequestTypeData,omitempty"`
	ClientID             string              `protobuf:"bytes,3,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string              `protobuf:"bytes,4,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string              `protobuf:"bytes,5,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte              `protobuf:"bytes,6,opt,name=Body,proto3" json:"Body,omitempty"`
	ReplyChannel         string              `protobuf:"bytes,7,opt,name=ReplyChannel,proto3" json:"ReplyChannel,omitempty"`
	Timeout              int32               `protobuf:"varint,8,opt,name=Timeout,proto3" json:"Timeout,omitempty"`
	CacheKey             string              `protobuf:"bytes,9,opt,name=CacheKey,proto3" json:"CacheKey,omitempty"`
	CacheTTL             int32               `protobuf:"varint,10,opt,name=CacheTTL,proto3" json:"CacheTTL,omitempty"`
	Span                 []byte              `protobuf:"bytes,11,opt,name=Span,proto3" json:"Span,omitempty"`
	Tags                 map[string]string   `protobuf:"bytes,12,rep,name=Tags,proto3" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Request) Reset()      { *m = Request{} }
func (*Request) ProtoMessage() {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{6}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Request) GetRequestTypeData() Request_RequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return Request_RequestTypeUnknown
}

func (m *Request) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Request) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Request) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Request) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Request) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Request) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *Request) GetCacheKey() string {
	if m != nil {
		return m.CacheKey
	}
	return ""
}

func (m *Request) GetCacheTTL() int32 {
	if m != nil {
		return m.CacheTTL
	}
	return 0
}

func (m *Request) GetSpan() []byte {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *Request) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Response struct {
	ClientID             string            `protobuf:"bytes,1,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	RequestID            string            `protobuf:"bytes,2,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ReplyChannel         string            `protobuf:"bytes,3,opt,name=ReplyChannel,proto3" json:"ReplyChannel,omitempty"`
	Metadata             string            `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte            `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	CacheHit             bool              `protobuf:"varint,6,opt,name=CacheHit,proto3" json:"CacheHit,omitempty"`
	Timestamp            int64             `protobuf:"varint,7,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Executed             bool              `protobuf:"varint,8,opt,name=Executed,proto3" json:"Executed,omitempty"`
	Error                string            `protobuf:"bytes,9,opt,name=Error,proto3" json:"Error,omitempty"`
	Span                 []byte            `protobuf:"bytes,10,opt,name=Span,proto3" json:"Span,omitempty"`
	Tags                 map[string]string `protobuf:"bytes,11,rep,name=Tags,proto3" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Response) Reset()      { *m = Response{} }
func (*Response) ProtoMessage() {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{7}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Response) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Response) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Response) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Response) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Response) GetCacheHit() bool {
	if m != nil {
		return m.CacheHit
	}
	return false
}

func (m *Response) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Response) GetExecuted() bool {
	if m != nil {
		return m.Executed
	}
	return false
}

func (m *Response) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Response) GetSpan() []byte {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *Response) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type QueueMessage struct {
	MessageID            string                  `protobuf:"bytes,1,opt,name=MessageID,proto3" json:"MessageID,omitempty"`
	ClientID             string                  `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string                  `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string                  `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte                  `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	Tags                 map[string]string       `protobuf:"bytes,6,rep,name=Tags,proto3" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Attributes           *QueueMessageAttributes `protobuf:"bytes,7,opt,name=Attributes,proto3" json:"Attributes,omitempty"`
	Policy               *QueueMessagePolicy     `protobuf:"bytes,8,opt,name=Policy,proto3" json:"Policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *QueueMessage) Reset()      { *m = QueueMessage{} }
func (*QueueMessage) ProtoMessage() {}
func (*QueueMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{8}
}
func (m *QueueMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessage.Merge(m, src)
}
func (m *QueueMessage) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessage.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessage proto.InternalMessageInfo

func (m *QueueMessage) GetMessageID() string {
	if m != nil {
		return m.MessageID
	}
	return ""
}

func (m *QueueMessage) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *QueueMessage) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *QueueMessage) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *QueueMessage) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *QueueMessage) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *QueueMessage) GetAttributes() *QueueMessageAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *QueueMessage) GetPolicy() *QueueMessagePolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

type QueueMessagesBatchRequest struct {
	BatchID              string          `protobuf:"bytes,1,opt,name=BatchID,proto3" json:"BatchID,omitempty"`
	Messages             []*QueueMessage `protobuf:"bytes,2,rep,name=Messages,proto3" json:"Messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *QueueMessagesBatchRequest) Reset()      { *m = QueueMessagesBatchRequest{} }
func (*QueueMessagesBatchRequest) ProtoMessage() {}
func (*QueueMessagesBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{9}
}
func (m *QueueMessagesBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessagesBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessagesBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessagesBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessagesBatchRequest.Merge(m, src)
}
func (m *QueueMessagesBatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessagesBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessagesBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessagesBatchRequest proto.InternalMessageInfo

func (m *QueueMessagesBatchRequest) GetBatchID() string {
	if m != nil {
		return m.BatchID
	}
	return ""
}

func (m *QueueMessagesBatchRequest) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type QueueMessagesBatchResponse struct {
	BatchID              string                    `protobuf:"bytes,1,opt,name=BatchID,proto3" json:"BatchID,omitempty"`
	Results              []*SendQueueMessageResult `protobuf:"bytes,2,rep,name=Results,proto3" json:"Results,omitempty"`
	HaveErrors           bool                      `protobuf:"varint,3,opt,name=HaveErrors,proto3" json:"HaveErrors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *QueueMessagesBatchResponse) Reset()      { *m = QueueMessagesBatchResponse{} }
func (*QueueMessagesBatchResponse) ProtoMessage() {}
func (*QueueMessagesBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{10}
}
func (m *QueueMessagesBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessagesBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessagesBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessagesBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessagesBatchResponse.Merge(m, src)
}
func (m *QueueMessagesBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessagesBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessagesBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessagesBatchResponse proto.InternalMessageInfo

func (m *QueueMessagesBatchResponse) GetBatchID() string {
	if m != nil {
		return m.BatchID
	}
	return ""
}

func (m *QueueMessagesBatchResponse) GetResults() []*SendQueueMessageResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *QueueMessagesBatchResponse) GetHaveErrors() bool {
	if m != nil {
		return m.HaveErrors
	}
	return false
}

type QueueMessageAttributes struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Sequence             uint64   `protobuf:"varint,2,opt,name=Sequence,proto3" json:"Sequence,omitempty"`
	MD5OfBody            string   `protobuf:"bytes,3,opt,name=MD5OfBody,proto3" json:"MD5OfBody,omitempty"`
	ReceiveCount         int32    `protobuf:"varint,4,opt,name=ReceiveCount,proto3" json:"ReceiveCount,omitempty"`
	ReRouted             bool     `protobuf:"varint,5,opt,name=ReRouted,proto3" json:"ReRouted,omitempty"`
	ReRoutedFromQueue    string   `protobuf:"bytes,6,opt,name=ReRoutedFromQueue,proto3" json:"ReRoutedFromQueue,omitempty"`
	ExpirationAt         int64    `protobuf:"varint,7,opt,name=ExpirationAt,proto3" json:"ExpirationAt,omitempty"`
	DelayedTo            int64    `protobuf:"varint,8,opt,name=DelayedTo,proto3" json:"DelayedTo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueMessageAttributes) Reset()      { *m = QueueMessageAttributes{} }
func (*QueueMessageAttributes) ProtoMessage() {}
func (*QueueMessageAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{11}
}
func (m *QueueMessageAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessageAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessageAttributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessageAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessageAttributes.Merge(m, src)
}
func (m *QueueMessageAttributes) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessageAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessageAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessageAttributes proto.InternalMessageInfo

func (m *QueueMessageAttributes) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *QueueMessageAttributes) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *QueueMessageAttributes) GetMD5OfBody() string {
	if m != nil {
		return m.MD5OfBody
	}
	return ""
}

func (m *QueueMessageAttributes) GetReceiveCount() int32 {
	if m != nil {
		return m.ReceiveCount
	}
	return 0
}

func (m *QueueMessageAttributes) GetReRouted() bool {
	if m != nil {
		return m.ReRouted
	}
	return false
}

func (m *QueueMessageAttributes) GetReRoutedFromQueue() string {
	if m != nil {
		return m.ReRoutedFromQueue
	}
	return ""
}

func (m *QueueMessageAttributes) GetExpirationAt() int64 {
	if m != nil {
		return m.ExpirationAt
	}
	return 0
}

func (m *QueueMessageAttributes) GetDelayedTo() int64 {
	if m != nil {
		return m.DelayedTo
	}
	return 0
}

type QueueMessagePolicy struct {
	ExpirationSeconds    int32    `protobuf:"varint,1,opt,name=ExpirationSeconds,proto3" json:"ExpirationSeconds,omitempty"`
	DelaySeconds         int32    `protobuf:"varint,2,opt,name=DelaySeconds,proto3" json:"DelaySeconds,omitempty"`
	MaxReceiveCount      int32    `protobuf:"varint,3,opt,name=MaxReceiveCount,proto3" json:"MaxReceiveCount,omitempty"`
	MaxReceiveQueue      string   `protobuf:"bytes,4,opt,name=MaxReceiveQueue,proto3" json:"MaxReceiveQueue,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueMessagePolicy) Reset()      { *m = QueueMessagePolicy{} }
func (*QueueMessagePolicy) ProtoMessage() {}
func (*QueueMessagePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{12}
}
func (m *QueueMessagePolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessagePolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessagePolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessagePolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessagePolicy.Merge(m, src)
}
func (m *QueueMessagePolicy) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessagePolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessagePolicy.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessagePolicy proto.InternalMessageInfo

func (m *QueueMessagePolicy) GetExpirationSeconds() int32 {
	if m != nil {
		return m.ExpirationSeconds
	}
	return 0
}

func (m *QueueMessagePolicy) GetDelaySeconds() int32 {
	if m != nil {
		return m.DelaySeconds
	}
	return 0
}

func (m *QueueMessagePolicy) GetMaxReceiveCount() int32 {
	if m != nil {
		return m.MaxReceiveCount
	}
	return 0
}

func (m *QueueMessagePolicy) GetMaxReceiveQueue() string {
	if m != nil {
		return m.MaxReceiveQueue
	}
	return ""
}

type SendQueueMessageResult struct {
	MessageID            string   `protobuf:"bytes,1,opt,name=MessageID,proto3" json:"MessageID,omitempty"`
	SentAt               int64    `protobuf:"varint,2,opt,name=SentAt,proto3" json:"SentAt,omitempty"`
	ExpirationAt         int64    `protobuf:"varint,3,opt,name=ExpirationAt,proto3" json:"ExpirationAt,omitempty"`
	DelayedTo            int64    `protobuf:"varint,4,opt,name=DelayedTo,proto3" json:"DelayedTo,omitempty"`
	IsError              bool     `protobuf:"varint,5,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string   `protobuf:"bytes,6,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendQueueMessageResult) Reset()      { *m = SendQueueMessageResult{} }
func (*SendQueueMessageResult) ProtoMessage() {}
func (*SendQueueMessageResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{13}
}
func (m *SendQueueMessageResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendQueueMessageResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendQueueMessageResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendQueueMessageResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendQueueMessageResult.Merge(m, src)
}
func (m *SendQueueMessageResult) XXX_Size() int {
	return m.Size()
}
func (m *SendQueueMessageResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SendQueueMessageResult.DiscardUnknown(m)
}

var xxx_messageInfo_SendQueueMessageResult proto.InternalMessageInfo

func (m *SendQueueMessageResult) GetMessageID() string {
	if m != nil {
		return m.MessageID
	}
	return ""
}

func (m *SendQueueMessageResult) GetSentAt() int64 {
	if m != nil {
		return m.SentAt
	}
	return 0
}

func (m *SendQueueMessageResult) GetExpirationAt() int64 {
	if m != nil {
		return m.ExpirationAt
	}
	return 0
}

func (m *SendQueueMessageResult) GetDelayedTo() int64 {
	if m != nil {
		return m.DelayedTo
	}
	return 0
}

func (m *SendQueueMessageResult) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *SendQueueMessageResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type ReceiveQueueMessagesRequest struct {
	RequestID            string   `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string   `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	MaxNumberOfMessages  int32    `protobuf:"varint,4,opt,name=MaxNumberOfMessages,proto3" json:"MaxNumberOfMessages,omitempty"`
	WaitTimeSeconds      int32    `protobuf:"varint,5,opt,name=WaitTimeSeconds,proto3" json:"WaitTimeSeconds,omitempty"`
	IsPeak               bool     `protobuf:"varint,6,opt,name=IsPeak,proto3" json:"IsPeak,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReceiveQueueMessagesRequest) Reset()      { *m = ReceiveQueueMessagesRequest{} }
func (*ReceiveQueueMessagesRequest) ProtoMessage() {}
func (*ReceiveQueueMessagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{14}
}
func (m *ReceiveQueueMessagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveQueueMessagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveQueueMessagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveQueueMessagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveQueueMessagesRequest.Merge(m, src)
}
func (m *ReceiveQueueMessagesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveQueueMessagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveQueueMessagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveQueueMessagesRequest proto.InternalMessageInfo

func (m *ReceiveQueueMessagesRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *ReceiveQueueMessagesRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *ReceiveQueueMessagesRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *ReceiveQueueMessagesRequest) GetMaxNumberOfMessages() int32 {
	if m != nil {
		return m.MaxNumberOfMessages
	}
	return 0
}

func (m *ReceiveQueueMessagesRequest) GetWaitTimeSeconds() int32 {
	if m != nil {
		return m.WaitTimeSeconds
	}
	return 0
}

func (m *ReceiveQueueMessagesRequest) GetIsPeak() bool {
	if m != nil {
		return m.IsPeak
	}
	return false
}

type ReceiveQueueMessagesResponse struct {
	RequestID            string          `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	Messages             []*QueueMessage `protobuf:"bytes,2,rep,name=Messages,proto3" json:"Messages,omitempty"`
	MessagesReceived     int32           `protobuf:"varint,3,opt,name=MessagesReceived,proto3" json:"MessagesReceived,omitempty"`
	MessagesExpired      int32           `protobuf:"varint,4,opt,name=MessagesExpired,proto3" json:"MessagesExpired,omitempty"`
	IsPeak               bool            `protobuf:"varint,5,opt,name=IsPeak,proto3" json:"IsPeak,omitempty"`
	IsError              bool            `protobuf:"varint,6,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string          `protobuf:"bytes,7,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReceiveQueueMessagesResponse) Reset()      { *m = ReceiveQueueMessagesResponse{} }
func (*ReceiveQueueMessagesResponse) ProtoMessage() {}
func (*ReceiveQueueMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{15}
}
func (m *ReceiveQueueMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveQueueMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveQueueMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveQueueMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveQueueMessagesResponse.Merge(m, src)
}
func (m *ReceiveQueueMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveQueueMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveQueueMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveQueueMessagesResponse proto.InternalMessageInfo

func (m *ReceiveQueueMessagesResponse) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *ReceiveQueueMessagesResponse) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *ReceiveQueueMessagesResponse) GetMessagesReceived() int32 {
	if m != nil {
		return m.MessagesReceived
	}
	return 0
}

func (m *ReceiveQueueMessagesResponse) GetMessagesExpired() int32 {
	if m != nil {
		return m.MessagesExpired
	}
	return 0
}

func (m *ReceiveQueueMessagesResponse) GetIsPeak() bool {
	if m != nil {
		return m.IsPeak
	}
	return false
}

func (m *ReceiveQueueMessagesResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *ReceiveQueueMessagesResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type AckAllQueueMessagesRequest struct {
	RequestID            string   `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string   `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	WaitTimeSeconds      int32    `protobuf:"varint,4,opt,name=WaitTimeSeconds,proto3" json:"WaitTimeSeconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AckAllQueueMessagesRequest) Reset()      { *m = AckAllQueueMessagesRequest{} }
func (*AckAllQueueMessagesRequest) ProtoMessage() {}
func (*AckAllQueueMessagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{16}
}
func (m *AckAllQueueMessagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AckAllQueueMessagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AckAllQueueMessagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AckAllQueueMessagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AckAllQueueMessagesRequest.Merge(m, src)
}
func (m *AckAllQueueMessagesRequest) XXX_Size() int {
	return m.Size()
}
func (m *AckAllQueueMessagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AckAllQueueMessagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AckAllQueueMessagesRequest proto.InternalMessageInfo

func (m *AckAllQueueMessagesRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *AckAllQueueMessagesRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *AckAllQueueMessagesRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *AckAllQueueMessagesRequest) GetWaitTimeSeconds() int32 {
	if m != nil {
		return m.WaitTimeSeconds
	}
	return 0
}

type AckAllQueueMessagesResponse struct {
	RequestID            string   `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	AffectedMessages     uint64   `protobuf:"varint,2,opt,name=AffectedMessages,proto3" json:"AffectedMessages,omitempty"`
	IsError              bool     `protobuf:"varint,3,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string   `protobuf:"bytes,4,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AckAllQueueMessagesResponse) Reset()      { *m = AckAllQueueMessagesResponse{} }
func (*AckAllQueueMessagesResponse) ProtoMessage() {}
func (*AckAllQueueMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{17}
}
func (m *AckAllQueueMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AckAllQueueMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AckAllQueueMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AckAllQueueMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AckAllQueueMessagesResponse.Merge(m, src)
}
func (m *AckAllQueueMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *AckAllQueueMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AckAllQueueMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AckAllQueueMessagesResponse proto.InternalMessageInfo

func (m *AckAllQueueMessagesResponse) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *AckAllQueueMessagesResponse) GetAffectedMessages() uint64 {
	if m != nil {
		return m.AffectedMessages
	}
	return 0
}

func (m *AckAllQueueMessagesResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *AckAllQueueMessagesResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type StreamQueueMessagesRequest struct {
	RequestID             string            `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID              string            `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	StreamRequestTypeData StreamRequestType `protobuf:"varint,3,opt,name=StreamRequestTypeData,proto3,enum=kubemq.StreamRequestType" json:"StreamRequestTypeData,omitempty"`
	Channel               string            `protobuf:"bytes,4,opt,name=Channel,proto3" json:"Channel,omitempty"`
	VisibilitySeconds     int32             `protobuf:"varint,5,opt,name=VisibilitySeconds,proto3" json:"VisibilitySeconds,omitempty"`
	WaitTimeSeconds       int32             `protobuf:"varint,6,opt,name=WaitTimeSeconds,proto3" json:"WaitTimeSeconds,omitempty"`
	RefSequence           uint64            `protobuf:"varint,7,opt,name=RefSequence,proto3" json:"RefSequence,omitempty"`
	ModifiedMessage       *QueueMessage     `protobuf:"bytes,8,opt,name=ModifiedMessage,proto3" json:"ModifiedMessage,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}          `json:"-"`
	XXX_unrecognized      []byte            `json:"-"`
	XXX_sizecache         int32             `json:"-"`
}

func (m *StreamQueueMessagesRequest) Reset()      { *m = StreamQueueMessagesRequest{} }
func (*StreamQueueMessagesRequest) ProtoMessage() {}
func (*StreamQueueMessagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{18}
}
func (m *StreamQueueMessagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamQueueMessagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamQueueMessagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamQueueMessagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamQueueMessagesRequest.Merge(m, src)
}
func (m *StreamQueueMessagesRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamQueueMessagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamQueueMessagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamQueueMessagesRequest proto.InternalMessageInfo

func (m *StreamQueueMessagesRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *StreamQueueMessagesRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *StreamQueueMessagesRequest) GetStreamRequestTypeData() StreamRequestType {
	if m != nil {
		return m.StreamRequestTypeData
	}
	return StreamRequestType_StreamRequestTypeUnknown
}

func (m *StreamQueueMessagesRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *StreamQueueMessagesRequest) GetVisibilitySeconds() int32 {
	if m != nil {
		return m.VisibilitySeconds
	}
	return 0
}

func (m *StreamQueueMessagesRequest) GetWaitTimeSeconds() int32 {
	if m != nil {
		return m.WaitTimeSeconds
	}
	return 0
}

func (m *StreamQueueMessagesRequest) GetRefSequence() uint64 {
	if m != nil {
		return m.RefSequence
	}
	return 0
}

func (m *StreamQueueMessagesRequest) GetModifiedMessage() *QueueMessage {
	if m != nil {
		return m.ModifiedMessage
	}
	return nil
}

type StreamQueueMessagesResponse struct {
	RequestID             string            `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	StreamRequestTypeData StreamRequestType `protobuf:"varint,2,opt,name=StreamRequestTypeData,proto3,enum=kubemq.StreamRequestType" json:"StreamRequestTypeData,omitempty"`
	Message               *QueueMessage     `protobuf:"bytes,3,opt,name=Message,proto3" json:"Message,omitempty"`
	IsError               bool              `protobuf:"varint,4,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                 string            `protobuf:"bytes,5,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}          `json:"-"`
	XXX_unrecognized      []byte            `json:"-"`
	XXX_sizecache         int32             `json:"-"`
}

func (m *StreamQueueMessagesResponse) Reset()      { *m = StreamQueueMessagesResponse{} }
func (*StreamQueueMessagesResponse) ProtoMessage() {}
func (*StreamQueueMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{19}
}
func (m *StreamQueueMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamQueueMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamQueueMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamQueueMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamQueueMessagesResponse.Merge(m, src)
}
func (m *StreamQueueMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *StreamQueueMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamQueueMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamQueueMessagesResponse proto.InternalMessageInfo

func (m *StreamQueueMessagesResponse) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *StreamQueueMessagesResponse) GetStreamRequestTypeData() StreamRequestType {
	if m != nil {
		return m.StreamRequestTypeData
	}
	return StreamRequestType_StreamRequestTypeUnknown
}

func (m *StreamQueueMessagesResponse) GetMessage() *QueueMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *StreamQueueMessagesResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *StreamQueueMessagesResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type QueuesUpstreamRequest struct {
	RequestID            string          `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	Messages             []*QueueMessage `protobuf:"bytes,2,rep,name=Messages,proto3" json:"Messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *QueuesUpstreamRequest) Reset()      { *m = QueuesUpstreamRequest{} }
func (*QueuesUpstreamRequest) ProtoMessage() {}
func (*QueuesUpstreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{20}
}
func (m *QueuesUpstreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesUpstreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesUpstreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesUpstreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesUpstreamRequest.Merge(m, src)
}
func (m *QueuesUpstreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueuesUpstreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesUpstreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesUpstreamRequest proto.InternalMessageInfo

func (m *QueuesUpstreamRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *QueuesUpstreamRequest) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type QueuesUpstreamResponse struct {
	RefRequestID         string                    `protobuf:"bytes,1,opt,name=RefRequestID,proto3" json:"RefRequestID,omitempty"`
	Results              []*SendQueueMessageResult `protobuf:"bytes,2,rep,name=Results,proto3" json:"Results,omitempty"`
	IsError              bool                      `protobuf:"varint,3,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string                    `protobuf:"bytes,4,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *QueuesUpstreamResponse) Reset()      { *m = QueuesUpstreamResponse{} }
func (*QueuesUpstreamResponse) ProtoMessage() {}
func (*QueuesUpstreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{21}
}
func (m *QueuesUpstreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesUpstreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesUpstreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesUpstreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesUpstreamResponse.Merge(m, src)
}
func (m *QueuesUpstreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueuesUpstreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesUpstreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesUpstreamResponse proto.InternalMessageInfo

func (m *QueuesUpstreamResponse) GetRefRequestID() string {
	if m != nil {
		return m.RefRequestID
	}
	return ""
}

func (m *QueuesUpstreamResponse) GetResults() []*SendQueueMessageResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *QueuesUpstreamResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *QueuesUpstreamResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type QueuesDownstreamRequest struct {
	RequestID            string                      `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID             string                      `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	RequestTypeData      QueuesDownstreamRequestType `protobuf:"varint,3,opt,name=RequestTypeData,proto3,enum=kubemq.QueuesDownstreamRequestType" json:"RequestTypeData,omitempty"`
	Channel              string                      `protobuf:"bytes,4,opt,name=Channel,proto3" json:"Channel,omitempty"`
	MaxItems             int32                       `protobuf:"varint,5,opt,name=MaxItems,proto3" json:"MaxItems,omitempty"`
	WaitTimeout          int32                       `protobuf:"varint,6,opt,name=WaitTimeout,proto3" json:"WaitTimeout,omitempty"`
	AutoAck              bool                        `protobuf:"varint,7,opt,name=AutoAck,proto3" json:"AutoAck,omitempty"`
	ReQueueChannel       string                      `protobuf:"bytes,8,opt,name=ReQueueChannel,proto3" json:"ReQueueChannel,omitempty"`
	SequenceRange        []int64                     `protobuf:"varint,9,rep,packed,name=SequenceRange,proto3" json:"SequenceRange,omitempty"`
	RefTransactionId     string                      `protobuf:"bytes,10,opt,name=RefTransactionId,proto3" json:"RefTransactionId,omitempty"`
	Metadata             map[string]string           `protobuf:"bytes,12,rep,name=Metadata,proto3" json:"Metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *QueuesDownstreamRequest) Reset()      { *m = QueuesDownstreamRequest{} }
func (*QueuesDownstreamRequest) ProtoMessage() {}
func (*QueuesDownstreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{22}
}
func (m *QueuesDownstreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesDownstreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesDownstreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesDownstreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesDownstreamRequest.Merge(m, src)
}
func (m *QueuesDownstreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueuesDownstreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesDownstreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesDownstreamRequest proto.InternalMessageInfo

func (m *QueuesDownstreamRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *QueuesDownstreamRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *QueuesDownstreamRequest) GetRequestTypeData() QueuesDownstreamRequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return QueuesDownstreamRequestType_PollRequestTypeUnknown
}

func (m *QueuesDownstreamRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *QueuesDownstreamRequest) GetMaxItems() int32 {
	if m != nil {
		return m.MaxItems
	}
	return 0
}

func (m *QueuesDownstreamRequest) GetWaitTimeout() int32 {
	if m != nil {
		return m.WaitTimeout
	}
	return 0
}

func (m *QueuesDownstreamRequest) GetAutoAck() bool {
	if m != nil {
		return m.AutoAck
	}
	return false
}

func (m *QueuesDownstreamRequest) GetReQueueChannel() string {
	if m != nil {
		return m.ReQueueChannel
	}
	return ""
}

func (m *QueuesDownstreamRequest) GetSequenceRange() []int64 {
	if m != nil {
		return m.SequenceRange
	}
	return nil
}

func (m *QueuesDownstreamRequest) GetRefTransactionId() string {
	if m != nil {
		return m.RefTransactionId
	}
	return ""
}

func (m *QueuesDownstreamRequest) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type QueuesDownstreamResponse struct {
	TransactionId        string                      `protobuf:"bytes,1,opt,name=TransactionId,proto3" json:"TransactionId,omitempty"`
	RefRequestId         string                      `protobuf:"bytes,2,opt,name=RefRequestId,proto3" json:"RefRequestId,omitempty"`
	RequestTypeData      QueuesDownstreamRequestType `protobuf:"varint,3,opt,name=RequestTypeData,proto3,enum=kubemq.QueuesDownstreamRequestType" json:"RequestTypeData,omitempty"`
	Messages             []*QueueMessage             `protobuf:"bytes,4,rep,name=Messages,proto3" json:"Messages,omitempty"`
	IsError              bool                        `protobuf:"varint,5,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string                      `protobuf:"bytes,6,opt,name=Error,proto3" json:"Error,omitempty"`
	Metadata             map[string]string           `protobuf:"bytes,7,rep,name=Metadata,proto3" json:"Metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *QueuesDownstreamResponse) Reset()      { *m = QueuesDownstreamResponse{} }
func (*QueuesDownstreamResponse) ProtoMessage() {}
func (*QueuesDownstreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{23}
}
func (m *QueuesDownstreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesDownstreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesDownstreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesDownstreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesDownstreamResponse.Merge(m, src)
}
func (m *QueuesDownstreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueuesDownstreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesDownstreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesDownstreamResponse proto.InternalMessageInfo

func (m *QueuesDownstreamResponse) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *QueuesDownstreamResponse) GetRefRequestId() string {
	if m != nil {
		return m.RefRequestId
	}
	return ""
}

func (m *QueuesDownstreamResponse) GetRequestTypeData() QueuesDownstreamRequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return QueuesDownstreamRequestType_PollRequestTypeUnknown
}

func (m *QueuesDownstreamResponse) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *QueuesDownstreamResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *QueuesDownstreamResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *QueuesDownstreamResponse) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func init() {
	proto.RegisterEnum("kubemq.StreamRequestType", StreamRequestType_name, StreamRequestType_value)
	proto.RegisterEnum("kubemq.QueuesDownstreamRequestType", QueuesDownstreamRequestType_name, QueuesDownstreamRequestType_value)
	proto.RegisterEnum("kubemq.Subscribe_SubscribeType", Subscribe_SubscribeType_name, Subscribe_SubscribeType_value)
	proto.RegisterEnum("kubemq.Subscribe_EventsStoreType", Subscribe_EventsStoreType_name, Subscribe_EventsStoreType_value)
	proto.RegisterEnum("kubemq.Request_RequestType", Request_RequestType_name, Request_RequestType_value)
	proto.RegisterType((*PingResult)(nil), "kubemq.PingResult")
	proto.RegisterType((*Empty)(nil), "kubemq.Empty")
	proto.RegisterType((*Result)(nil), "kubemq.Result")
	proto.RegisterType((*Event)(nil), "kubemq.Event")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.Event.TagsEntry")
	proto.RegisterType((*EventReceive)(nil), "kubemq.EventReceive")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.EventReceive.TagsEntry")
	proto.RegisterType((*Subscribe)(nil), "kubemq.Subscribe")
	proto.RegisterType((*Request)(nil), "kubemq.Request")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.Request.TagsEntry")
	proto.RegisterType((*Response)(nil), "kubemq.Response")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.Response.TagsEntry")
	proto.RegisterType((*QueueMessage)(nil), "kubemq.QueueMessage")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.QueueMessage.TagsEntry")
	proto.RegisterType((*QueueMessagesBatchRequest)(nil), "kubemq.QueueMessagesBatchRequest")
	proto.RegisterType((*QueueMessagesBatchResponse)(nil), "kubemq.QueueMessagesBatchResponse")
	proto.RegisterType((*QueueMessageAttributes)(nil), "kubemq.QueueMessageAttributes")
	proto.RegisterType((*QueueMessagePolicy)(nil), "kubemq.QueueMessagePolicy")
	proto.RegisterType((*SendQueueMessageResult)(nil), "kubemq.SendQueueMessageResult")
	proto.RegisterType((*ReceiveQueueMessagesRequest)(nil), "kubemq.ReceiveQueueMessagesRequest")
	proto.RegisterType((*ReceiveQueueMessagesResponse)(nil), "kubemq.ReceiveQueueMessagesResponse")
	proto.RegisterType((*AckAllQueueMessagesRequest)(nil), "kubemq.AckAllQueueMessagesRequest")
	proto.RegisterType((*AckAllQueueMessagesResponse)(nil), "kubemq.AckAllQueueMessagesResponse")
	proto.RegisterType((*StreamQueueMessagesRequest)(nil), "kubemq.StreamQueueMessagesRequest")
	proto.RegisterType((*StreamQueueMessagesResponse)(nil), "kubemq.StreamQueueMessagesResponse")
	proto.RegisterType((*QueuesUpstreamRequest)(nil), "kubemq.QueuesUpstreamRequest")
	proto.RegisterType((*QueuesUpstreamResponse)(nil), "kubemq.QueuesUpstreamResponse")
	proto.RegisterType((*QueuesDownstreamRequest)(nil), "kubemq.QueuesDownstreamRequest")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.QueuesDownstreamRequest.MetadataEntry")
	proto.RegisterType((*QueuesDownstreamResponse)(nil), "kubemq.QueuesDownstreamResponse")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.QueuesDownstreamResponse.MetadataEntry")
}

func init() { proto.RegisterFile("kubemq_go.proto", fileDescriptor_3c4052a8d0b3cbdc) }

var fileDescriptor_3c4052a8d0b3cbdc = []byte{
	// 2183 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x19, 0x4d, 0x6f, 0x1c, 0x49,
	0x75, 0x7a, 0xba, 0xe7, 0xeb, 0xf9, 0xab, 0x5d, 0xf6, 0x3a, 0xbd, 0x9d, 0x30, 0xeb, 0xed, 0x44,
	0xc8, 0xca, 0x66, 0x47, 0xc1, 0x08, 0xed, 0x0a, 0xb4, 0x2b, 0x26, 0xb6, 0x77, 0xe3, 0x25, 0x4e,
	0xbc, 0x35, 0x76, 0x38, 0x70, 0x80, 0xf6, 0x4c, 0xd9, 0x69, 0x3c, 0xd3, 0x3d, 0xdb, 0x5d, 0xe3,
	0x78, 0x6e, 0x20, 0xc4, 0x8d, 0x03, 0x12, 0xd2, 0xf2, 0x71, 0x40, 0x1c, 0x10, 0x42, 0xfc, 0x02,
	0x04, 0x97, 0x3d, 0x72, 0xe4, 0xc8, 0x91, 0x18, 0x71, 0xe3, 0x80, 0xc4, 0x05, 0x89, 0x0b, 0xaa,
	0x8f, 0xee, 0xa9, 0xfe, 0x98, 0x71, 0x1c, 0xcc, 0xde, 0xfa, 0xbd, 0x7a, 0x55, 0xef, 0xfb, 0xd5,
	0x7b, 0xd5, 0xb0, 0x74, 0x3a, 0x3a, 0x22, 0x83, 0x4f, 0xbe, 0x7d, 0x12, 0xb4, 0x86, 0x61, 0x40,
	0x03, 0x54, 0x15, 0x08, 0x1b, 0x4e, 0x82, 0x18, 0xe7, 0x7c, 0xaa, 0x01, 0xec, 0x7b, 0xfe, 0x09,
	0x26, 0xd1, 0xa8, 0x4f, 0x11, 0x02, 0xe3, 0x61, 0x10, 0x51, 0x4b, 0x5b, 0xd7, 0x36, 0x1a, 0x98,
	0x7f, 0x23, 0x0b, 0x6a, 0x4f, 0x49, 0x18, 0x79, 0x81, 0x6f, 0x95, 0x39, 0x3a, 0x06, 0xd1, 0x06,
	0x2c, 0x75, 0x48, 0x78, 0x46, 0xc2, 0x0e, 0x75, 0x43, 0x7a, 0xe0, 0x0d, 0x88, 0xa5, 0xaf, 0x6b,
	0x1b, 0x3a, 0xce, 0xa2, 0xd1, 0x7d, 0x58, 0x11, 0xa8, 0xc3, 0x21, 0x83, 0x3b, 0xa4, 0x1b, 0xf8,
	0xbd, 0xc8, 0x32, 0x38, 0x75, 0xd1, 0x92, 0x53, 0x83, 0xca, 0xce, 0x60, 0x48, 0xc7, 0xce, 0x23,
	0xa8, 0x4a, 0xe1, 0x2c, 0xa8, 0xed, 0x9c, 0x11, 0x9f, 0xee, 0x6e, 0x4b, 0xf9, 0x62, 0x90, 0x89,
	0xdd, 0x21, 0x3e, 0xe5, 0xf2, 0xd5, 0x31, 0xff, 0x46, 0xab, 0x50, 0xd9, 0x09, 0xc3, 0x20, 0xe4,
	0x22, 0x35, 0xb0, 0x00, 0x9c, 0x1f, 0x94, 0xa1, 0xc2, 0x77, 0xcd, 0x38, 0xcd, 0x86, 0xfa, 0x56,
	0xdf, 0x13, 0x4b, 0x42, 0xe3, 0x04, 0x66, 0xbb, 0xb6, 0x9e, 0xb9, 0xbe, 0x4f, 0xfa, 0xf2, 0xdc,
	0x18, 0x64, 0xbb, 0xf6, 0x08, 0x75, 0x7b, 0x2e, 0x75, 0xb9, 0x5e, 0x0d, 0x9c, 0xc0, 0x4c, 0xbe,
	0x07, 0x41, 0x6f, 0x6c, 0x55, 0xd6, 0xb5, 0x8d, 0x79, 0xcc, 0xbf, 0x99, 0x7c, 0x1d, 0x1a, 0x84,
	0xc4, 0xaa, 0x72, 0xa1, 0x05, 0x80, 0xde, 0x02, 0xe3, 0xc0, 0x3d, 0x89, 0xac, 0xda, 0xba, 0xbe,
	0x31, 0xb7, 0x79, 0xa3, 0x25, 0x5c, 0xd6, 0xe2, 0xa2, 0xb5, 0xd8, 0xca, 0x8e, 0x4f, 0xc3, 0x31,
	0xe6, 0x44, 0xf6, 0x3b, 0xd0, 0x48, 0x50, 0xc8, 0x04, 0xfd, 0x94, 0x8c, 0xa5, 0x2e, 0xec, 0x93,
	0x71, 0x38, 0x73, 0xfb, 0x23, 0x22, 0x95, 0x10, 0xc0, 0x57, 0xcb, 0xef, 0x6a, 0xce, 0xcf, 0xcb,
	0x30, 0xcf, 0x8f, 0xc4, 0xa4, 0x4b, 0xbc, 0x33, 0x32, 0xc3, 0x18, 0x8a, 0xc2, 0xe5, 0xe9, 0x0a,
	0xeb, 0x53, 0x14, 0x36, 0x14, 0x85, 0x6f, 0x41, 0x83, 0x39, 0x38, 0xa2, 0xee, 0x60, 0xc8, 0x2d,
	0xa1, 0xe3, 0x09, 0x82, 0x9d, 0xd6, 0x21, 0x9f, 0x8c, 0x88, 0xdf, 0x15, 0x16, 0x31, 0x70, 0x02,
	0xa3, 0xcd, 0x94, 0x51, 0x9a, 0x29, 0xa3, 0x48, 0x0d, 0xae, 0xcf, 0x36, 0x7f, 0x34, 0xa0, 0xd1,
	0x19, 0x1d, 0x45, 0xdd, 0xd0, 0x3b, 0x22, 0x68, 0x0f, 0x96, 0x13, 0xe0, 0x60, 0x3c, 0x24, 0xdb,
	0x4c, 0x5b, 0x76, 0xce, 0xe2, 0xe6, 0x1b, 0xb1, 0x1c, 0x09, 0x41, 0x2b, 0x45, 0x8a, 0xf3, 0x3b,
	0x5f, 0x31, 0xb4, 0x56, 0xa1, 0xf2, 0x61, 0x18, 0x8c, 0x86, 0x32, 0xae, 0x04, 0x80, 0x3a, 0xb0,
	0xc2, 0x2d, 0x10, 0xf1, 0xc8, 0x49, 0x84, 0xab, 0x70, 0xe1, 0xde, 0xcc, 0x0b, 0x97, 0x21, 0xc6,
	0x45, 0xbb, 0xd1, 0x26, 0xac, 0x66, 0xd0, 0x4f, 0xb9, 0x99, 0xaa, 0xdc, 0x5f, 0x85, 0x6b, 0x4e,
	0x17, 0x16, 0x52, 0x9a, 0x22, 0x1b, 0xd6, 0x52, 0x88, 0x43, 0xbf, 0x47, 0x8e, 0x3d, 0x9f, 0xf4,
	0xcc, 0x12, 0x02, 0xa8, 0x8a, 0x43, 0x4c, 0x0d, 0x2d, 0xc1, 0x9c, 0x72, 0xa0, 0x59, 0x46, 0xf3,
	0x50, 0xdf, 0x0a, 0x06, 0x03, 0xd7, 0xef, 0x45, 0xa6, 0x8e, 0xe6, 0xa0, 0xf6, 0xf1, 0x88, 0x84,
	0x1e, 0x89, 0x4c, 0xc3, 0xf9, 0xb5, 0x06, 0x4b, 0x19, 0xee, 0xe8, 0x16, 0x58, 0x19, 0x94, 0xca,
	0xc9, 0x84, 0x79, 0x5e, 0x80, 0x1e, 0x93, 0xe7, 0x4f, 0xfc, 0xfe, 0xd8, 0xd4, 0x10, 0x82, 0x45,
	0x8e, 0xf9, 0x20, 0x0c, 0x06, 0x1f, 0x78, 0x61, 0x44, 0xcd, 0x32, 0x5a, 0x86, 0x85, 0x04, 0xf7,
	0xc8, 0x8d, 0xa8, 0xa9, 0xa3, 0x15, 0x58, 0xe2, 0xa8, 0x36, 0x8d, 0x23, 0xd0, 0x34, 0x98, 0xac,
	0x12, 0xc9, 0x62, 0xd6, 0xac, 0xa0, 0x55, 0x30, 0x15, 0xc4, 0x36, 0xe9, 0x53, 0xd7, 0xac, 0x3a,
	0x3f, 0x34, 0xa0, 0x86, 0xd9, 0xae, 0x88, 0xb2, 0x80, 0x97, 0x9f, 0x49, 0x5a, 0x4d, 0x10, 0x68,
	0x07, 0x96, 0x24, 0x90, 0xb8, 0xae, 0xcc, 0x5d, 0x77, 0x33, 0x76, 0x9d, 0x5c, 0x6e, 0x29, 0x64,
	0x38, 0xbb, 0x27, 0x15, 0x51, 0xfa, 0xf4, 0x88, 0x32, 0xa6, 0xe7, 0x6e, 0x65, 0x4a, 0xee, 0x56,
	0x95, 0xdc, 0x75, 0x60, 0x1e, 0x93, 0x61, 0x7f, 0x1c, 0x1f, 0x57, 0xe3, 0x7b, 0x52, 0x38, 0xc6,
	0x8d, 0x59, 0x22, 0x18, 0x51, 0xab, 0xbe, 0xae, 0x6d, 0x54, 0x70, 0x0c, 0x72, 0x19, 0xdd, 0xee,
	0x33, 0xf2, 0x0d, 0x32, 0xb6, 0x1a, 0x52, 0x46, 0x09, 0x27, 0x6b, 0x07, 0x07, 0x8f, 0x2c, 0xe0,
	0xdb, 0x12, 0x98, 0x97, 0xf5, 0xa1, 0xeb, 0x5b, 0x73, 0x42, 0x12, 0xf6, 0x8d, 0xde, 0x96, 0xb5,
	0x60, 0x9e, 0xd7, 0x82, 0xd7, 0xb3, 0xb6, 0xba, 0xb6, 0x32, 0xf0, 0x1e, 0xcc, 0x29, 0xa6, 0x46,
	0x6b, 0x80, 0x14, 0xf0, 0xd0, 0x3f, 0xf5, 0x83, 0xe7, 0xbe, 0x59, 0x62, 0x31, 0x2a, 0x23, 0xd6,
	0xd4, 0x50, 0x03, 0x2a, 0x2c, 0x60, 0xc7, 0x66, 0xd9, 0xf9, 0xbe, 0x0e, 0x75, 0x4c, 0xa2, 0x61,
	0xe0, 0x47, 0x24, 0xe5, 0x23, 0x2d, 0xe3, 0xa3, 0x54, 0x90, 0x94, 0xb3, 0x41, 0x92, 0xb5, 0xbb,
	0x5e, 0x60, 0xf7, 0xab, 0x5e, 0x3c, 0xb1, 0xc5, 0x1f, 0x7a, 0x54, 0xde, 0x3d, 0x09, 0x9c, 0xae,
	0xd1, 0xb5, 0x82, 0x1a, 0xbd, 0x73, 0x4e, 0xba, 0x23, 0x4a, 0x7a, 0xdc, 0xc5, 0x75, 0x9c, 0xc0,
	0x93, 0xeb, 0xb6, 0xa1, 0x5c, 0xb7, 0x89, 0x07, 0x41, 0xf1, 0x60, 0x4b, 0x7a, 0x70, 0x8e, 0x7b,
	0xd0, 0x9e, 0x78, 0x50, 0x58, 0xeb, 0xfa, 0x5c, 0xf8, 0xaf, 0x32, 0xcc, 0x7f, 0x3c, 0x22, 0x23,
	0xb2, 0x47, 0xa2, 0xc8, 0x3d, 0x61, 0xf5, 0xa2, 0x21, 0x3f, 0x27, 0x09, 0x99, 0x20, 0x3e, 0xa7,
	0x6b, 0x3f, 0xbe, 0xcb, 0xaa, 0xe9, 0xbb, 0x4c, 0x95, 0x33, 0x6b, 0x01, 0xf4, 0x3e, 0x40, 0x9b,
	0xd2, 0xd0, 0x3b, 0x1a, 0x51, 0x12, 0x71, 0xb7, 0x4c, 0xd9, 0x39, 0xa1, 0xc2, 0xca, 0x0e, 0xb4,
	0x09, 0xd5, 0xfd, 0xa0, 0xef, 0x75, 0xc7, 0xdc, 0x6b, 0x8a, 0xcd, 0xd5, 0xbd, 0x82, 0x02, 0x4b,
	0xca, 0x57, 0xb7, 0xfa, 0x09, 0xbc, 0xae, 0x1e, 0x1b, 0x3d, 0x70, 0x69, 0xf7, 0x59, 0x5c, 0x12,
	0x2d, 0xa8, 0x71, 0x78, 0xd2, 0x67, 0x48, 0x10, 0xdd, 0x67, 0x76, 0x14, 0x3b, 0xac, 0x32, 0xb7,
	0xcd, 0x6a, 0x91, 0x94, 0x38, 0xa1, 0x72, 0x7e, 0xac, 0x81, 0x5d, 0xc4, 0x49, 0x26, 0xdd, 0x74,
	0x56, 0xef, 0xb2, 0x12, 0xcd, 0x3a, 0xca, 0x98, 0x53, 0x62, 0xcb, 0x0e, 0xf1, 0x7b, 0x29, 0x6e,
	0x9c, 0x0c, 0xc7, 0xe4, 0xa8, 0x09, 0xf0, 0xd0, 0x3d, 0x23, 0x3c, 0xb6, 0x23, 0x1e, 0x09, 0x75,
	0xac, 0x60, 0x9c, 0x5f, 0x95, 0x61, 0xad, 0xd8, 0x1f, 0xe9, 0xcc, 0xd2, 0x66, 0x75, 0x3f, 0xe5,
	0x4c, 0xf7, 0xc3, 0xa2, 0x76, 0xfb, 0x2b, 0x4f, 0x8e, 0x79, 0x28, 0xe9, 0x32, 0x6a, 0x63, 0x84,
	0xa8, 0x10, 0xbc, 0x05, 0xda, 0x0a, 0x46, 0x3e, 0xe5, 0x31, 0x58, 0xc1, 0x29, 0x1c, 0x3b, 0x1d,
	0x13, 0x1c, 0xf0, 0xbc, 0xad, 0x88, 0xbc, 0x8d, 0x61, 0x74, 0x0f, 0x96, 0xe3, 0x6f, 0x76, 0x05,
	0x72, 0xe9, 0x79, 0x59, 0x68, 0xe0, 0xfc, 0x02, 0xe3, 0xb6, 0x73, 0x3e, 0xf4, 0x42, 0x97, 0x7a,
	0x81, 0xdf, 0xa6, 0xb2, 0x44, 0xa4, 0x70, 0x4c, 0xde, 0x6d, 0xd2, 0x77, 0xc7, 0xa4, 0x77, 0x10,
	0xf0, 0x80, 0xd3, 0xf1, 0x04, 0xe1, 0xfc, 0x41, 0x03, 0x94, 0x0f, 0x3b, 0x26, 0xc6, 0xe4, 0x90,
	0x78, 0x3c, 0xd0, 0xb8, 0x2e, 0xf9, 0x05, 0x26, 0x06, 0x3f, 0x31, 0x26, 0x2c, 0x0b, 0xa5, 0x55,
	0x1c, 0x1b, 0x4e, 0xf6, 0xdc, 0xf3, 0x94, 0x6d, 0x74, 0x4e, 0x96, 0x45, 0xa7, 0x29, 0x85, 0x01,
	0x44, 0x26, 0x67, 0xd1, 0xce, 0x67, 0x1a, 0xac, 0x15, 0xc7, 0xc8, 0x25, 0xb5, 0x65, 0x0d, 0xaa,
	0x6c, 0x28, 0x69, 0x8b, 0x11, 0x45, 0xc7, 0x12, 0xca, 0xd9, 0x53, 0xbf, 0xcc, 0x9e, 0x46, 0xc6,
	0x9e, 0x2c, 0xcc, 0x77, 0x23, 0x51, 0x79, 0x85, 0x6b, 0x63, 0x70, 0x52, 0x91, 0xab, 0xea, 0x00,
	0xf4, 0x77, 0x0d, 0x6e, 0xaa, 0x3a, 0xc5, 0xc9, 0xf3, 0x72, 0x4d, 0xcb, 0xab, 0xd5, 0xc8, 0xfb,
	0xb0, 0xb2, 0xe7, 0x9e, 0x3f, 0x1e, 0x0d, 0x8e, 0x48, 0xf8, 0xe4, 0x38, 0x49, 0x73, 0x11, 0xaa,
	0x45, 0x4b, 0xcc, 0x25, 0xdf, 0x74, 0x3d, 0xaa, 0xce, 0x8a, 0x15, 0xe1, 0xbc, 0x0c, 0x9a, 0x59,
	0x76, 0x37, 0xda, 0x27, 0xee, 0xa9, 0xbc, 0xcb, 0x24, 0xe4, 0xfc, 0xa8, 0x0c, 0xb7, 0x8a, 0xf5,
	0x94, 0xf5, 0x61, 0xb6, 0xa2, 0x57, 0x2e, 0x47, 0xe8, 0x2e, 0x98, 0x13, 0x1e, 0x9c, 0x6f, 0x4f,
	0x06, 0x5c, 0x0e, 0xcf, 0x23, 0x4e, 0xe2, 0xb8, 0xab, 0x49, 0x4f, 0x1a, 0x23, 0x8b, 0x56, 0xd4,
	0xab, 0xa8, 0xea, 0xa9, 0x6e, 0xaf, 0x4e, 0x71, 0x7b, 0x4d, 0x75, 0xfb, 0x2f, 0x34, 0xb0, 0xdb,
	0xdd, 0xd3, 0x76, 0xbf, 0xff, 0xb9, 0x79, 0xbd, 0xc0, 0x87, 0x46, 0xa1, 0x0f, 0x9d, 0x9f, 0x6a,
	0x70, 0xb3, 0x50, 0xb8, 0x97, 0x72, 0xd5, 0x5d, 0x30, 0xdb, 0xc7, 0xc7, 0xa4, 0x4b, 0x49, 0x4f,
	0x71, 0x19, 0xab, 0xa1, 0x39, 0xbc, 0x6a, 0x36, 0x7d, 0x8a, 0xd9, 0x0c, 0xd5, 0x6c, 0xff, 0x29,
	0x83, 0xdd, 0xa1, 0x21, 0x71, 0x07, 0xd7, 0x6c, 0xb6, 0x27, 0xf0, 0x9a, 0x38, 0x37, 0x3b, 0x03,
	0xe8, 0x7c, 0x06, 0x48, 0xfa, 0xda, 0x1c, 0x11, 0x2e, 0xde, 0x37, 0xa3, 0xd7, 0xbf, 0x07, 0xcb,
	0x4f, 0xbd, 0xc8, 0x3b, 0xf2, 0xfa, 0x1e, 0x1d, 0xa7, 0xb3, 0x29, 0xbf, 0x50, 0xe4, 0xb5, 0x6a,
	0x71, 0xe6, 0xad, 0xb3, 0x0e, 0xf9, 0x38, 0xb9, 0xb6, 0x6a, 0xdc, 0xe4, 0x2a, 0x0a, 0xbd, 0x0f,
	0x4b, 0x7b, 0x41, 0xcf, 0x3b, 0xf6, 0x12, 0x0f, 0xc8, 0x06, 0xa4, 0x38, 0x97, 0xb2, 0xc4, 0xce,
	0x3f, 0x34, 0xb8, 0x59, 0x68, 0xfd, 0x97, 0x8a, 0x8b, 0xa9, 0x26, 0x2e, 0xbf, 0xa2, 0x89, 0x5b,
	0x50, 0x8b, 0xd5, 0xd0, 0x67, 0xa8, 0x11, 0x13, 0xa9, 0xc1, 0x66, 0x4c, 0x09, 0xb6, 0x8a, 0x1a,
	0x6c, 0x27, 0xf0, 0x1a, 0x3f, 0x28, 0x3a, 0x1c, 0x46, 0xaa, 0x00, 0xd7, 0x5d, 0xaa, 0x9c, 0xdf,
	0x68, 0xb2, 0x4d, 0x51, 0x38, 0x49, 0x93, 0xf2, 0x76, 0xe2, 0x38, 0xcb, 0x2d, 0x85, 0xfb, 0x1f,
	0xfa, 0xa7, 0xab, 0xa6, 0xdf, 0xa7, 0x06, 0xdc, 0x10, 0x82, 0x6e, 0x07, 0xcf, 0xfd, 0xab, 0x18,
	0x65, 0x56, 0xee, 0xed, 0xe5, 0x27, 0x6f, 0x91, 0x75, 0xb7, 0x53, 0x76, 0xcb, 0xf3, 0x2c, 0x9e,
	0xc0, 0x67, 0x4f, 0xd9, 0xee, 0xf9, 0x2e, 0x25, 0x83, 0x38, 0xe1, 0x12, 0x98, 0x65, 0x4f, 0x9c,
	0x50, 0x6c, 0x62, 0x16, 0x39, 0xa6, 0xa2, 0xd8, 0xb9, 0xed, 0x11, 0x0d, 0xda, 0xdd, 0x53, 0x9e,
	0x5b, 0x75, 0x1c, 0x83, 0xe8, 0x8b, 0xb0, 0x88, 0xc5, 0xad, 0x16, 0x33, 0xae, 0x73, 0xc6, 0x19,
	0x2c, 0xba, 0x03, 0x0b, 0x71, 0x2e, 0x62, 0xd7, 0x3f, 0x21, 0x56, 0x63, 0x5d, 0xdf, 0xd0, 0x71,
	0x1a, 0xc9, 0xea, 0x27, 0x26, 0xc7, 0x07, 0xa1, 0xeb, 0x47, 0x6e, 0x97, 0xf5, 0x1c, 0xbb, 0x3d,
	0x3e, 0xaf, 0x35, 0x70, 0x0e, 0x8f, 0x76, 0x95, 0x69, 0x47, 0x4c, 0xe0, 0x6f, 0x5f, 0x62, 0xb3,
	0x56, 0x4c, 0x2f, 0x06, 0x9a, 0x64, 0xbb, 0xfd, 0x35, 0x58, 0x48, 0x2d, 0x5d, 0x69, 0xc8, 0xf8,
	0xa5, 0x0e, 0x56, 0x9e, 0xa1, 0x8c, 0xe1, 0x3b, 0xb0, 0x90, 0xd6, 0x46, 0x1c, 0x99, 0x46, 0x66,
	0x22, 0xbd, 0x27, 0x79, 0xa4, 0x70, 0xd7, 0x1d, 0x29, 0x6a, 0xa6, 0x1a, 0x2f, 0xd5, 0x54, 0x5c,
	0xb1, 0xbb, 0x43, 0x1f, 0x29, 0xfe, 0x11, 0xaf, 0xa5, 0xad, 0xe9, 0x92, 0xca, 0x79, 0xfb, 0xff,
	0xe1, 0xa0, 0xbb, 0xbf, 0xd3, 0x60, 0x39, 0x57, 0x45, 0xd1, 0x2d, 0xb0, 0x72, 0xc8, 0xc9, 0x5b,
	0x0a, 0x62, 0x61, 0xcd, 0x3b, 0x24, 0xa9, 0xbf, 0xa9, 0xa1, 0x45, 0x80, 0x76, 0xf7, 0x34, 0x86,
	0xf9, 0x73, 0x1d, 0x26, 0xdf, 0x25, 0x5d, 0x1a, 0xa3, 0x74, 0xb4, 0x0a, 0x26, 0xbf, 0x38, 0xc6,
	0x93, 0xcb, 0xcc, 0x34, 0x04, 0x61, 0x44, 0xfc, 0xf8, 0x32, 0x31, 0x2b, 0xe8, 0x06, 0xac, 0xb0,
	0x02, 0x95, 0xb9, 0x65, 0xcc, 0xea, 0xdd, 0xcf, 0x34, 0xb8, 0x39, 0xc3, 0x91, 0xc8, 0x86, 0xb5,
	0xfd, 0xa0, 0xdf, 0x2f, 0x14, 0xba, 0x06, 0xfa, 0x87, 0x84, 0x9a, 0x1a, 0x02, 0xa8, 0x8a, 0x1e,
	0x46, 0xbc, 0x63, 0xb6, 0xbb, 0xa7, 0x3c, 0xbd, 0xc4, 0x3b, 0xe6, 0x63, 0xb9, 0x64, 0xa0, 0x05,
	0x68, 0x3c, 0x4e, 0xd6, 0x2a, 0x4c, 0x3f, 0x99, 0xb4, 0x6c, 0xb9, 0x8a, 0x4c, 0x16, 0x95, 0x1c,
	0x16, 0x14, 0x35, 0xa6, 0xc8, 0x56, 0x3f, 0x88, 0xc8, 0x83, 0xb1, 0x28, 0x60, 0x66, 0x5d, 0x41,
	0x89, 0x3f, 0x27, 0x66, 0x63, 0xf3, 0x27, 0x75, 0x90, 0xbf, 0x77, 0xd0, 0x3d, 0x68, 0x30, 0x35,
	0xc5, 0x5f, 0x8e, 0x85, 0xd4, 0x63, 0xb9, 0xbd, 0xa8, 0xbc, 0xb6, 0x8c, 0xfa, 0xd4, 0x29, 0xa1,
	0x77, 0xc0, 0x4c, 0xa8, 0x23, 0xe1, 0x9c, 0x4b, 0x37, 0x6d, 0x68, 0xf7, 0x35, 0xf4, 0x75, 0xf5,
	0x65, 0x3c, 0x10, 0xfb, 0xd1, 0x72, 0xee, 0xd9, 0xd9, 0x5e, 0x2d, 0x7a, 0xae, 0x77, 0x4a, 0xf7,
	0x35, 0xf4, 0x1e, 0xac, 0x28, 0x27, 0x48, 0xeb, 0x16, 0x9e, 0xb1, 0x94, 0x79, 0xe6, 0xe3, 0xdb,
	0x37, 0x61, 0x8e, 0x49, 0x1e, 0xdf, 0x07, 0x59, 0x1a, 0xdb, 0xcc, 0xbe, 0x2c, 0x39, 0x25, 0xf4,
	0x25, 0x98, 0x17, 0x7b, 0x64, 0xa9, 0xc8, 0xd1, 0xd8, 0x13, 0xdd, 0xf9, 0xdf, 0xa7, 0x12, 0xfa,
	0x48, 0x18, 0x28, 0xf5, 0x90, 0x54, 0x98, 0xb6, 0xf6, 0x25, 0xd7, 0xa0, 0x53, 0x42, 0x6e, 0x7e,
	0x7c, 0x14, 0xaf, 0x16, 0xe8, 0xcd, 0xa2, 0x13, 0x53, 0x6f, 0x27, 0xb6, 0x33, 0x8b, 0x24, 0xd1,
	0xb0, 0x0b, 0xab, 0x45, 0x63, 0x0f, 0xba, 0x3d, 0xd1, 0x74, 0xea, 0xf0, 0x67, 0xdf, 0x99, 0x4d,
	0xa4, 0x30, 0x41, 0xf9, 0xbe, 0x0c, 0x39, 0xe9, 0x8e, 0xaa, 0x90, 0xc3, 0xed, 0x99, 0x34, 0x31,
	0x03, 0x1e, 0x60, 0xdf, 0x81, 0x95, 0x82, 0xa1, 0x60, 0xc2, 0x65, 0xfa, 0x38, 0x33, 0xe1, 0x32,
	0x63, 0xaa, 0x70, 0x4a, 0xe8, 0x2d, 0x30, 0xf6, 0x3d, 0xff, 0x04, 0xa5, 0x7d, 0x6e, 0xa3, 0x18,
	0x9c, 0xfc, 0x18, 0x75, 0x4a, 0xe8, 0x5b, 0x60, 0x66, 0x6b, 0x04, 0x7a, 0xe3, 0x92, 0x6b, 0xc0,
	0x5e, 0xbf, 0xac, 0xfa, 0x4a, 0x5d, 0x0f, 0x61, 0x31, 0xdd, 0x90, 0xa1, 0x2f, 0xa4, 0x77, 0x66,
	0x5a, 0x42, 0xbb, 0x39, 0x6d, 0x59, 0x3d, 0xf6, 0xc1, 0xc6, 0x5f, 0x5e, 0x34, 0x4b, 0xff, 0x7c,
	0xd1, 0xd4, 0xfe, 0xfd, 0xa2, 0xa9, 0x7d, 0xef, 0xa2, 0xa9, 0xfd, 0xf6, 0xa2, 0xa9, 0xfd, 0xfe,
	0xa2, 0xa9, 0xfd, 0xe9, 0xa2, 0xa9, 0xfd, 0xf9, 0xa2, 0xa9, 0xfd, 0xf5, 0xa2, 0xa9, 0xfd, 0xec,
	0x6f, 0xcd, 0xd2, 0x51, 0x95, 0xff, 0x0e, 0xfe, 0xf2, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x63,
	0xe0, 0xc2, 0x22, 0x35, 0x1e, 0x00, 0x00,
}

func (this *PingResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PingResult)
	if !ok {
		that2, ok := that.(PingResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.ServerStartTime != that1.ServerStartTime {
		return false
	}
	if this.ServerUpTimeSeconds != that1.ServerUpTimeSeconds {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Result) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Result)
	if !ok {
		that2, ok := that.(Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.Sent != that1.Sent {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Event) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Event)
	if !ok {
		that2, ok := that.(Event)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.Store != that1.Store {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *EventReceive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventReceive)
	if !ok {
		that2, ok := that.(EventReceive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Sequence != that1.Sequence {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Subscribe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Subscribe)
	if !ok {
		that2, ok := that.(Subscribe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubscribeTypeData != that1.SubscribeTypeData {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Group != that1.Group {
		return false
	}
	if this.EventsStoreTypeData != that1.EventsStoreTypeData {
		return false
	}
	if this.EventsStoreTypeValue != that1.EventsStoreTypeValue {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.RequestTypeData != that1.RequestTypeData {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.ReplyChannel != that1.ReplyChannel {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if this.CacheKey != that1.CacheKey {
		return false
	}
	if this.CacheTTL != that1.CacheTTL {
		return false
	}
	if !bytes.Equal(this.Span, that1.Span) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Response) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Response)
	if !ok {
		that2, ok := that.(Response)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ReplyChannel != that1.ReplyChannel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.CacheHit != that1.CacheHit {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Executed != that1.Executed {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.Span, that1.Span) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessage)
	if !ok {
		that2, ok := that.(QueueMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MessageID != that1.MessageID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !this.Attributes.Equal(that1.Attributes) {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueMessagesBatchRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessagesBatchRequest)
	if !ok {
		that2, ok := that.(QueueMessagesBatchRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BatchID != that1.BatchID {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueMessagesBatchResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessagesBatchResponse)
	if !ok {
		that2, ok := that.(QueueMessagesBatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BatchID != that1.BatchID {
		return false
	}
	if len(this.Results) != len(that1.Results) {
		return false
	}
	for i := range this.Results {
		if !this.Results[i].Equal(that1.Results[i]) {
			return false
		}
	}
	if this.HaveErrors != that1.HaveErrors {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueMessageAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessageAttributes)
	if !ok {
		that2, ok := that.(QueueMessageAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Sequence != that1.Sequence {
		return false
	}
	if this.MD5OfBody != that1.MD5OfBody {
		return false
	}
	if this.ReceiveCount != that1.ReceiveCount {
		return false
	}
	if this.ReRouted != that1.ReRouted {
		return false
	}
	if this.ReRoutedFromQueue != that1.ReRoutedFromQueue {
		return false
	}
	if this.ExpirationAt != that1.ExpirationAt {
		return false
	}
	if this.DelayedTo != that1.DelayedTo {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueMessagePolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessagePolicy)
	if !ok {
		that2, ok := that.(QueueMessagePolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpirationSeconds != that1.ExpirationSeconds {
		return false
	}
	if this.DelaySeconds != that1.DelaySeconds {
		return false
	}
	if this.MaxReceiveCount != that1.MaxReceiveCount {
		return false
	}
	if this.MaxReceiveQueue != that1.MaxReceiveQueue {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SendQueueMessageResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendQueueMessageResult)
	if !ok {
		that2, ok := that.(SendQueueMessageResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MessageID != that1.MessageID {
		return false
	}
	if this.SentAt != that1.SentAt {
		return false
	}
	if this.ExpirationAt != that1.ExpirationAt {
		return false
	}
	if this.DelayedTo != that1.DelayedTo {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReceiveQueueMessagesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReceiveQueueMessagesRequest)
	if !ok {
		that2, ok := that.(ReceiveQueueMessagesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.MaxNumberOfMessages != that1.MaxNumberOfMessages {
		return false
	}
	if this.WaitTimeSeconds != that1.WaitTimeSeconds {
		return false
	}
	if this.IsPeak != that1.IsPeak {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReceiveQueueMessagesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReceiveQueueMessagesResponse)
	if !ok {
		that2, ok := that.(ReceiveQueueMessagesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if this.MessagesReceived != that1.MessagesReceived {
		return false
	}
	if this.MessagesExpired != that1.MessagesExpired {
		return false
	}
	if this.IsPeak != that1.IsPeak {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AckAllQueueMessagesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AckAllQueueMessagesRequest)
	if !ok {
		that2, ok := that.(AckAllQueueMessagesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.WaitTimeSeconds != that1.WaitTimeSeconds {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AckAllQueueMessagesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AckAllQueueMessagesResponse)
	if !ok {
		that2, ok := that.(AckAllQueueMessagesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.AffectedMessages != that1.AffectedMessages {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *StreamQueueMessagesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamQueueMessagesRequest)
	if !ok {
		that2, ok := that.(StreamQueueMessagesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.StreamRequestTypeData != that1.StreamRequestTypeData {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.VisibilitySeconds != that1.VisibilitySeconds {
		return false
	}
	if this.WaitTimeSeconds != that1.WaitTimeSeconds {
		return false
	}
	if this.RefSequence != that1.RefSequence {
		return false
	}
	if !this.ModifiedMessage.Equal(that1.ModifiedMessage) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *StreamQueueMessagesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamQueueMessagesResponse)
	if !ok {
		that2, ok := that.(StreamQueueMessagesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.StreamRequestTypeData != that1.StreamRequestTypeData {
		return false
	}
	if !this.Message.Equal(that1.Message) {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesUpstreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesUpstreamRequest)
	if !ok {
		that2, ok := that.(QueuesUpstreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesUpstreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesUpstreamResponse)
	if !ok {
		that2, ok := that.(QueuesUpstreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RefRequestID != that1.RefRequestID {
		return false
	}
	if len(this.Results) != len(that1.Results) {
		return false
	}
	for i := range this.Results {
		if !this.Results[i].Equal(that1.Results[i]) {
			return false
		}
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesDownstreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesDownstreamRequest)
	if !ok {
		that2, ok := that.(QueuesDownstreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.RequestTypeData != that1.RequestTypeData {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.MaxItems != that1.MaxItems {
		return false
	}
	if this.WaitTimeout != that1.WaitTimeout {
		return false
	}
	if this.AutoAck != that1.AutoAck {
		return false
	}
	if this.ReQueueChannel != that1.ReQueueChannel {
		return false
	}
	if len(this.SequenceRange) != len(that1.SequenceRange) {
		return false
	}
	for i := range this.SequenceRange {
		if this.SequenceRange[i] != that1.SequenceRange[i] {
			return false
		}
	}
	if this.RefTransactionId != that1.RefTransactionId {
		return false
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesDownstreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesDownstreamResponse)
	if !ok {
		that2, ok := that.(QueuesDownstreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TransactionId != that1.TransactionId {
		return false
	}
	if this.RefRequestId != that1.RefRequestId {
		return false
	}
	if this.RequestTypeData != that1.RequestTypeData {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PingResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.PingResult{")
	s = append(s, "Host: "+fmt.Sprintf("%#v", this.Host)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "ServerStartTime: "+fmt.Sprintf("%#v", this.ServerStartTime)+",\n")
	s = append(s, "ServerUpTimeSeconds: "+fmt.Sprintf("%#v", this.ServerUpTimeSeconds)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&kubemq.Empty{")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&kubemq.Result{")
	s = append(s, "EventID: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "Sent: "+fmt.Sprintf("%#v", this.Sent)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Event) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&kubemq.Event{")
	s = append(s, "EventID: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "Store: "+fmt.Sprintf("%#v", this.Store)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EventReceive) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&kubemq.EventReceive{")
	s = append(s, "EventID: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Sequence: "+fmt.Sprintf("%#v", this.Sequence)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Subscribe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.Subscribe{")
	s = append(s, "SubscribeTypeData: "+fmt.Sprintf("%#v", this.SubscribeTypeData)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	s = append(s, "EventsStoreTypeData: "+fmt.Sprintf("%#v", this.EventsStoreTypeData)+",\n")
	s = append(s, "EventsStoreTypeValue: "+fmt.Sprintf("%#v", this.EventsStoreTypeValue)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Request) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&kubemq.Request{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "RequestTypeData: "+fmt.Sprintf("%#v", this.RequestTypeData)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "ReplyChannel: "+fmt.Sprintf("%#v", this.ReplyChannel)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "CacheKey: "+fmt.Sprintf("%#v", this.CacheKey)+",\n")
	s = append(s, "CacheTTL: "+fmt.Sprintf("%#v", this.CacheTTL)+",\n")
	s = append(s, "Span: "+fmt.Sprintf("%#v", this.Span)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Response) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&kubemq.Response{")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ReplyChannel: "+fmt.Sprintf("%#v", this.ReplyChannel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "CacheHit: "+fmt.Sprintf("%#v", this.CacheHit)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Executed: "+fmt.Sprintf("%#v", this.Executed)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "Span: "+fmt.Sprintf("%#v", this.Span)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&kubemq.QueueMessage{")
	s = append(s, "MessageID: "+fmt.Sprintf("%#v", this.MessageID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.Attributes != nil {
		s = append(s, "Attributes: "+fmt.Sprintf("%#v", this.Attributes)+",\n")
	}
	if this.Policy != nil {
		s = append(s, "Policy: "+fmt.Sprintf("%#v", this.Policy)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessagesBatchRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&kubemq.QueueMessagesBatchRequest{")
	s = append(s, "BatchID: "+fmt.Sprintf("%#v", this.BatchID)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessagesBatchResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&kubemq.QueueMessagesBatchResponse{")
	s = append(s, "BatchID: "+fmt.Sprintf("%#v", this.BatchID)+",\n")
	if this.Results != nil {
		s = append(s, "Results: "+fmt.Sprintf("%#v", this.Results)+",\n")
	}
	s = append(s, "HaveErrors: "+fmt.Sprintf("%#v", this.HaveErrors)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessageAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&kubemq.QueueMessageAttributes{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Sequence: "+fmt.Sprintf("%#v", this.Sequence)+",\n")
	s = append(s, "MD5OfBody: "+fmt.Sprintf("%#v", this.MD5OfBody)+",\n")
	s = append(s, "ReceiveCount: "+fmt.Sprintf("%#v", this.ReceiveCount)+",\n")
	s = append(s, "ReRouted: "+fmt.Sprintf("%#v", this.ReRouted)+",\n")
	s = append(s, "ReRoutedFromQueue: "+fmt.Sprintf("%#v", this.ReRoutedFromQueue)+",\n")
	s = append(s, "ExpirationAt: "+fmt.Sprintf("%#v", this.ExpirationAt)+",\n")
	s = append(s, "DelayedTo: "+fmt.Sprintf("%#v", this.DelayedTo)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessagePolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.QueueMessagePolicy{")
	s = append(s, "ExpirationSeconds: "+fmt.Sprintf("%#v", this.ExpirationSeconds)+",\n")
	s = append(s, "DelaySeconds: "+fmt.Sprintf("%#v", this.DelaySeconds)+",\n")
	s = append(s, "MaxReceiveCount: "+fmt.Sprintf("%#v", this.MaxReceiveCount)+",\n")
	s = append(s, "MaxReceiveQueue: "+fmt.Sprintf("%#v", this.MaxReceiveQueue)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendQueueMessageResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.SendQueueMessageResult{")
	s = append(s, "MessageID: "+fmt.Sprintf("%#v", this.MessageID)+",\n")
	s = append(s, "SentAt: "+fmt.Sprintf("%#v", this.SentAt)+",\n")
	s = append(s, "ExpirationAt: "+fmt.Sprintf("%#v", this.ExpirationAt)+",\n")
	s = append(s, "DelayedTo: "+fmt.Sprintf("%#v", this.DelayedTo)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReceiveQueueMessagesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.ReceiveQueueMessagesRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "MaxNumberOfMessages: "+fmt.Sprintf("%#v", this.MaxNumberOfMessages)+",\n")
	s = append(s, "WaitTimeSeconds: "+fmt.Sprintf("%#v", this.WaitTimeSeconds)+",\n")
	s = append(s, "IsPeak: "+fmt.Sprintf("%#v", this.IsPeak)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReceiveQueueMessagesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&kubemq.ReceiveQueueMessagesResponse{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	s = append(s, "MessagesReceived: "+fmt.Sprintf("%#v", this.MessagesReceived)+",\n")
	s = append(s, "MessagesExpired: "+fmt.Sprintf("%#v", this.MessagesExpired)+",\n")
	s = append(s, "IsPeak: "+fmt.Sprintf("%#v", this.IsPeak)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AckAllQueueMessagesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.AckAllQueueMessagesRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "WaitTimeSeconds: "+fmt.Sprintf("%#v", this.WaitTimeSeconds)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AckAllQueueMessagesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.AckAllQueueMessagesResponse{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "AffectedMessages: "+fmt.Sprintf("%#v", this.AffectedMessages)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamQueueMessagesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&kubemq.StreamQueueMessagesRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "StreamRequestTypeData: "+fmt.Sprintf("%#v", this.StreamRequestTypeData)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "VisibilitySeconds: "+fmt.Sprintf("%#v", this.VisibilitySeconds)+",\n")
	s = append(s, "WaitTimeSeconds: "+fmt.Sprintf("%#v", this.WaitTimeSeconds)+",\n")
	s = append(s, "RefSequence: "+fmt.Sprintf("%#v", this.RefSequence)+",\n")
	if this.ModifiedMessage != nil {
		s = append(s, "ModifiedMessage: "+fmt.Sprintf("%#v", this.ModifiedMessage)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamQueueMessagesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&kubemq.StreamQueueMessagesResponse{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "StreamRequestTypeData: "+fmt.Sprintf("%#v", this.StreamRequestTypeData)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesUpstreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&kubemq.QueuesUpstreamRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesUpstreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.QueuesUpstreamResponse{")
	s = append(s, "RefRequestID: "+fmt.Sprintf("%#v", this.RefRequestID)+",\n")
	if this.Results != nil {
		s = append(s, "Results: "+fmt.Sprintf("%#v", this.Results)+",\n")
	}
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesDownstreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&kubemq.QueuesDownstreamRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "RequestTypeData: "+fmt.Sprintf("%#v", this.RequestTypeData)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "MaxItems: "+fmt.Sprintf("%#v", this.MaxItems)+",\n")
	s = append(s, "WaitTimeout: "+fmt.Sprintf("%#v", this.WaitTimeout)+",\n")
	s = append(s, "AutoAck: "+fmt.Sprintf("%#v", this.AutoAck)+",\n")
	s = append(s, "ReQueueChannel: "+fmt.Sprintf("%#v", this.ReQueueChannel)+",\n")
	s = append(s, "SequenceRange: "+fmt.Sprintf("%#v", this.SequenceRange)+",\n")
	s = append(s, "RefTransactionId: "+fmt.Sprintf("%#v", this.RefTransactionId)+",\n")
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%#v: %#v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	if this.Metadata != nil {
		s = append(s, "Metadata: "+mapStringForMetadata+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesDownstreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&kubemq.QueuesDownstreamResponse{")
	s = append(s, "TransactionId: "+fmt.Sprintf("%#v", this.TransactionId)+",\n")
	s = append(s, "RefRequestId: "+fmt.Sprintf("%#v", this.RefRequestId)+",\n")
	s = append(s, "RequestTypeData: "+fmt.Sprintf("%#v", this.RequestTypeData)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%#v: %#v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	if this.Metadata != nil {
		s = append(s, "Metadata: "+mapStringForMetadata+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringKubemqGo(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// KubemqClient is the client API for Kubemq service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KubemqClient interface {
	SendEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Result, error)
	SendEventsStream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_SendEventsStreamClient, error)
	SubscribeToEvents(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToEventsClient, error)
	SubscribeToRequests(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToRequestsClient, error)
	SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error)
	SendQueueMessage(ctx context.Context, in *QueueMessage, opts ...grpc.CallOption) (*SendQueueMessageResult, error)
	SendQueueMessagesBatch(ctx context.Context, in *QueueMessagesBatchRequest, opts ...grpc.CallOption) (*QueueMessagesBatchResponse, error)
	ReceiveQueueMessages(ctx context.Context, in *ReceiveQueueMessagesRequest, opts ...grpc.CallOption) (*ReceiveQueueMessagesResponse, error)
	StreamQueueMessage(ctx context.Context, opts ...grpc.CallOption) (Kubemq_StreamQueueMessageClient, error)
	AckAllQueueMessages(ctx context.Context, in *AckAllQueueMessagesRequest, opts ...grpc.CallOption) (*AckAllQueueMessagesResponse, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PingResult, error)
	QueuesDownstream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_QueuesDownstreamClient, error)
	QueuesUpstream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_QueuesUpstreamClient, error)
}

type kubemqClient struct {
	cc *grpc.ClientConn
}

func NewKubemqClient(cc *grpc.ClientConn) KubemqClient {
	return &kubemqClient{cc}
}

func (c *kubemqClient) SendEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendEventsStream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_SendEventsStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[0], "/kubemq.kubemq/SendEventsStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSendEventsStreamClient{stream}
	return x, nil
}

type Kubemq_SendEventsStreamClient interface {
	Send(*Event) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type kubemqSendEventsStreamClient struct {
	grpc.ClientStream
}

func (x *kubemqSendEventsStreamClient) Send(m *Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqSendEventsStreamClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SubscribeToEvents(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[1], "/kubemq.kubemq/SubscribeToEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSubscribeToEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Kubemq_SubscribeToEventsClient interface {
	Recv() (*EventReceive, error)
	grpc.ClientStream
}

type kubemqSubscribeToEventsClient struct {
	grpc.ClientStream
}

func (x *kubemqSubscribeToEventsClient) Recv() (*EventReceive, error) {
	m := new(EventReceive)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SubscribeToRequests(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToRequestsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[2], "/kubemq.kubemq/SubscribeToRequests", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSubscribeToRequestsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Kubemq_SubscribeToRequestsClient interface {
	Recv() (*Request, error)
	grpc.ClientStream
}

type kubemqSubscribeToRequestsClient struct {
	grpc.ClientStream
}

func (x *kubemqSubscribeToRequestsClient) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendResponse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendQueueMessage(ctx context.Context, in *QueueMessage, opts ...grpc.CallOption) (*SendQueueMessageResult, error) {
	out := new(SendQueueMessageResult)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendQueueMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendQueueMessagesBatch(ctx context.Context, in *QueueMessagesBatchRequest, opts ...grpc.CallOption) (*QueueMessagesBatchResponse, error) {
	out := new(QueueMessagesBatchResponse)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendQueueMessagesBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) ReceiveQueueMessages(ctx context.Context, in *ReceiveQueueMessagesRequest, opts ...grpc.CallOption) (*ReceiveQueueMessagesResponse, error) {
	out := new(ReceiveQueueMessagesResponse)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/ReceiveQueueMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) StreamQueueMessage(ctx context.Context, opts ...grpc.CallOption) (Kubemq_StreamQueueMessageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[3], "/kubemq.kubemq/StreamQueueMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqStreamQueueMessageClient{stream}
	return x, nil
}

type Kubemq_StreamQueueMessageClient interface {
	Send(*StreamQueueMessagesRequest) error
	Recv() (*StreamQueueMessagesResponse, error)
	grpc.ClientStream
}

type kubemqStreamQueueMessageClient struct {
	grpc.ClientStream
}

func (x *kubemqStreamQueueMessageClient) Send(m *StreamQueueMessagesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqStreamQueueMessageClient) Recv() (*StreamQueueMessagesResponse, error) {
	m := new(StreamQueueMessagesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) AckAllQueueMessages(ctx context.Context, in *AckAllQueueMessagesRequest, opts ...grpc.CallOption) (*AckAllQueueMessagesResponse, error) {
	out := new(AckAllQueueMessagesResponse)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/AckAllQueueMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PingResult, error) {
	out := new(PingResult)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) QueuesDownstream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_QueuesDownstreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[4], "/kubemq.kubemq/QueuesDownstream", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqQueuesDownstreamClient{stream}
	return x, nil
}

type Kubemq_QueuesDownstreamClient interface {
	Send(*QueuesDownstreamRequest) error
	Recv() (*QueuesDownstreamResponse, error)
	grpc.ClientStream
}

type kubemqQueuesDownstreamClient struct {
	grpc.ClientStream
}

func (x *kubemqQueuesDownstreamClient) Send(m *QueuesDownstreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqQueuesDownstreamClient) Recv() (*QueuesDownstreamResponse, error) {
	m := new(QueuesDownstreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) QueuesUpstream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_QueuesUpstreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[5], "/kubemq.kubemq/QueuesUpstream", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqQueuesUpstreamClient{stream}
	return x, nil
}

type Kubemq_QueuesUpstreamClient interface {
	Send(*QueuesUpstreamRequest) error
	Recv() (*QueuesUpstreamResponse, error)
	grpc.ClientStream
}

type kubemqQueuesUpstreamClient struct {
	grpc.ClientStream
}

func (x *kubemqQueuesUpstreamClient) Send(m *QueuesUpstreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqQueuesUpstreamClient) Recv() (*QueuesUpstreamResponse, error) {
	m := new(QueuesUpstreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KubemqServer is the server API for Kubemq service.
type KubemqServer interface {
	SendEvent(context.Context, *Event) (*Result, error)
	SendEventsStream(Kubemq_SendEventsStreamServer) error
	SubscribeToEvents(*Subscribe, Kubemq_SubscribeToEventsServer) error
	SubscribeToRequests(*Subscribe, Kubemq_SubscribeToRequestsServer) error
	SendRequest(context.Context, *Request) (*Response, error)
	SendResponse(context.Context, *Response) (*Empty, error)
	SendQueueMessage(context.Context, *QueueMessage) (*SendQueueMessageResult, error)
	SendQueueMessagesBatch(context.Context, *QueueMessagesBatchRequest) (*QueueMessagesBatchResponse, error)
	ReceiveQueueMessages(context.Context, *ReceiveQueueMessagesRequest) (*ReceiveQueueMessagesResponse, error)
	StreamQueueMessage(Kubemq_StreamQueueMessageServer) error
	AckAllQueueMessages(context.Context, *AckAllQueueMessagesRequest) (*AckAllQueueMessagesResponse, error)
	Ping(context.Context, *Empty) (*PingResult, error)
	QueuesDownstream(Kubemq_QueuesDownstreamServer) error
	QueuesUpstream(Kubemq_QueuesUpstreamServer) error
}

func RegisterKubemqServer(s *grpc.Server, srv KubemqServer) {
	s.RegisterService(&_Kubemq_serviceDesc, srv)
}

func _Kubemq_SendEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendEventsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).SendEventsStream(&kubemqSendEventsStreamServer{stream})
}

type Kubemq_SendEventsStreamServer interface {
	Send(*Result) error
	Recv() (*Event, error)
	grpc.ServerStream
}

type kubemqSendEventsStreamServer struct {
	grpc.ServerStream
}

func (x *kubemqSendEventsStreamServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqSendEventsStreamServer) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_SubscribeToEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubemqServer).SubscribeToEvents(m, &kubemqSubscribeToEventsServer{stream})
}

type Kubemq_SubscribeToEventsServer interface {
	Send(*EventReceive) error
	grpc.ServerStream
}

type kubemqSubscribeToEventsServer struct {
	grpc.ServerStream
}

func (x *kubemqSubscribeToEventsServer) Send(m *EventReceive) error {
	return x.ServerStream.SendMsg(m)
}

func _Kubemq_SubscribeToRequests_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubemqServer).SubscribeToRequests(m, &kubemqSubscribeToRequestsServer{stream})
}

type Kubemq_SubscribeToRequestsServer interface {
	Send(*Request) error
	grpc.ServerStream
}

type kubemqSubscribeToRequestsServer struct {
	grpc.ServerStream
}

func (x *kubemqSubscribeToRequestsServer) Send(m *Request) error {
	return x.ServerStream.SendMsg(m)
}

func _Kubemq_SendRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendRequest(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendResponse(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendQueueMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendQueueMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendQueueMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendQueueMessage(ctx, req.(*QueueMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendQueueMessagesBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueMessagesBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendQueueMessagesBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendQueueMessagesBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendQueueMessagesBatch(ctx, req.(*QueueMessagesBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_ReceiveQueueMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveQueueMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).ReceiveQueueMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/ReceiveQueueMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).ReceiveQueueMessages(ctx, req.(*ReceiveQueueMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_StreamQueueMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).StreamQueueMessage(&kubemqStreamQueueMessageServer{stream})
}

type Kubemq_StreamQueueMessageServer interface {
	Send(*StreamQueueMessagesResponse) error
	Recv() (*StreamQueueMessagesRequest, error)
	grpc.ServerStream
}

type kubemqStreamQueueMessageServer struct {
	grpc.ServerStream
}

func (x *kubemqStreamQueueMessageServer) Send(m *StreamQueueMessagesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqStreamQueueMessageServer) Recv() (*StreamQueueMessagesRequest, error) {
	m := new(StreamQueueMessagesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_AckAllQueueMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckAllQueueMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).AckAllQueueMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/AckAllQueueMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).AckAllQueueMessages(ctx, req.(*AckAllQueueMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_QueuesDownstream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).QueuesDownstream(&kubemqQueuesDownstreamServer{stream})
}

type Kubemq_QueuesDownstreamServer interface {
	Send(*QueuesDownstreamResponse) error
	Recv() (*QueuesDownstreamRequest, error)
	grpc.ServerStream
}

type kubemqQueuesDownstreamServer struct {
	grpc.ServerStream
}

func (x *kubemqQueuesDownstreamServer) Send(m *QueuesDownstreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqQueuesDownstreamServer) Recv() (*QueuesDownstreamRequest, error) {
	m := new(QueuesDownstreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_QueuesUpstream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).QueuesUpstream(&kubemqQueuesUpstreamServer{stream})
}

type Kubemq_QueuesUpstreamServer interface {
	Send(*QueuesUpstreamResponse) error
	Recv() (*QueuesUpstreamRequest, error)
	grpc.ServerStream
}

type kubemqQueuesUpstreamServer struct {
	grpc.ServerStream
}

func (x *kubemqQueuesUpstreamServer) Send(m *QueuesUpstreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqQueuesUpstreamServer) Recv() (*QueuesUpstreamRequest, error) {
	m := new(QueuesUpstreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Kubemq_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kubemq.kubemq",
	HandlerType: (*KubemqServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendEvent",
			Handler:    _Kubemq_SendEvent_Handler,
		},
		{
			MethodName: "SendRequest",
			Handler:    _Kubemq_SendRequest_Handler,
		},
		{
			MethodName: "SendResponse",
			Handler:    _Kubemq_SendResponse_Handler,
		},
		{
			MethodName: "SendQueueMessage",
			Handler:    _Kubemq_SendQueueMessage_Handler,
		},
		{
			MethodName: "SendQueueMessagesBatch",
			Handler:    _Kubemq_SendQueueMessagesBatch_Handler,
		},
		{
			MethodName: "ReceiveQueueMessages",
			Handler:    _Kubemq_ReceiveQueueMessages_Handler,
		},
		{
			MethodName: "AckAllQueueMessages",
			Handler:    _Kubemq_AckAllQueueMessages_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Kubemq_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendEventsStream",
			Handler:       _Kubemq_SendEventsStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeToEvents",
			Handler:       _Kubemq_SubscribeToEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToRequests",
			Handler:       _Kubemq_SubscribeToRequests_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamQueueMessage",
			Handler:       _Kubemq_StreamQueueMessage_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "QueuesDownstream",
			Handler:       _Kubemq_QueuesDownstream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "QueuesUpstream",
			Handler:       _Kubemq_QueuesUpstream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "kubemq_go.proto",
}

func (m *PingResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.ServerStartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ServerStartTime))
	}
	if m.ServerUpTimeSeconds != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ServerUpTimeSeconds))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if m.Sent {
		dAtA[i] = 0x10
		i++
		if m.Sent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.Store {
		dAtA[i] = 0x30
		i++
		if m.Store {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x3a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EventReceive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReceive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Sequence))
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x3a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Subscribe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subscribe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubscribeTypeData != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SubscribeTypeData))
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if m.EventsStoreTypeData != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.EventsStoreTypeData))
	}
	if m.EventsStoreTypeValue != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.EventsStoreTypeValue))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.RequestTypeData != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RequestTypeData))
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.ReplyChannel) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReplyChannel)))
		i += copy(dAtA[i:], m.ReplyChannel)
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timeout))
	}
	if len(m.CacheKey) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.CacheKey)))
		i += copy(dAtA[i:], m.CacheKey)
	}
	if m.CacheTTL != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.CacheTTL))
	}
	if len(m.Span) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Span)))
		i += copy(dAtA[i:], m.Span)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x62
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.RequestID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ReplyChannel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReplyChannel)))
		i += copy(dAtA[i:], m.ReplyChannel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.CacheHit {
		dAtA[i] = 0x30
		i++
		if m.CacheHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Executed {
		dAtA[i] = 0x40
		i++
		if m.Executed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Span) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Span)))
		i += copy(dAtA[i:], m.Span)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x5a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MessageID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MessageID)))
		i += copy(dAtA[i:], m.MessageID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x32
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Attributes != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Attributes.Size()))
		n1, err := m.Attributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Policy != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Policy.Size()))
		n2, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessagesBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessagesBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BatchID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.BatchID)))
		i += copy(dAtA[i:], m.BatchID)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessagesBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessagesBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BatchID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.BatchID)))
		i += copy(dAtA[i:], m.BatchID)
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HaveErrors {
		dAtA[i] = 0x18
		i++
		if m.HaveErrors {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessageAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessageAttributes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Sequence))
	}
	if len(m.MD5OfBody) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MD5OfBody)))
		i += copy(dAtA[i:], m.MD5OfBody)
	}
	if m.ReceiveCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ReceiveCount))
	}
	if m.ReRouted {
		dAtA[i] = 0x28
		i++
		if m.ReRouted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ReRoutedFromQueue) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReRoutedFromQueue)))
		i += copy(dAtA[i:], m.ReRoutedFromQueue)
	}
	if m.ExpirationAt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.DelayedTo))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessagePolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessagePolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExpirationSeconds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ExpirationSeconds))
	}
	if m.DelaySeconds != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.DelaySeconds))
	}
	if m.MaxReceiveCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MaxReceiveCount))
	}
	if len(m.MaxReceiveQueue) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MaxReceiveQueue)))
		i += copy(dAtA[i:], m.MaxReceiveQueue)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SendQueueMessageResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendQueueMessageResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MessageID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MessageID)))
		i += copy(dAtA[i:], m.MessageID)
	}
	if m.SentAt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SentAt))
	}
	if m.ExpirationAt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.DelayedTo))
	}
	if m.IsError {
		dAtA[i] = 0x28
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReceiveQueueMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveQueueMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.MaxNumberOfMessages != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MaxNumberOfMessages))
	}
	if m.WaitTimeSeconds != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeSeconds))
	}
	if m.IsPeak {
		dAtA[i] = 0x30
		i++
		if m.IsPeak {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReceiveQueueMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveQueueMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MessagesReceived != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MessagesReceived))
	}
	if m.MessagesExpired != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MessagesExpired))
	}
	if m.IsPeak {
		dAtA[i] = 0x28
		i++
		if m.IsPeak {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsError {
		dAtA[i] = 0x30
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AckAllQueueMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AckAllQueueMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.WaitTimeSeconds != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeSeconds))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AckAllQueueMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AckAllQueueMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.AffectedMessages != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.AffectedMessages))
	}
	if m.IsError {
		dAtA[i] = 0x18
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamQueueMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamQueueMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if m.StreamRequestTypeData != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.StreamRequestTypeData))
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.VisibilitySeconds != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.VisibilitySeconds))
	}
	if m.WaitTimeSeconds != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeSeconds))
	}
	if m.RefSequence != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RefSequence))
	}
	if m.ModifiedMessage != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ModifiedMessage.Size()))
		n3, err := m.ModifiedMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamQueueMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamQueueMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.StreamRequestTypeData != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.StreamRequestTypeData))
	}
	if m.Message != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Message.Size()))
		n4, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.IsError {
		dAtA[i] = 0x20
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesUpstreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesUpstreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesUpstreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesUpstreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RefRequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefRequestID)))
		i += copy(dAtA[i:], m.RefRequestID)
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsError {
		dAtA[i] = 0x18
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesDownstreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesDownstreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if m.RequestTypeData != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RequestTypeData))
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.MaxItems != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MaxItems))
	}
	if m.WaitTimeout != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeout))
	}
	if m.AutoAck {
		dAtA[i] = 0x38
		i++
		if m.AutoAck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ReQueueChannel) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReQueueChannel)))
		i += copy(dAtA[i:], m.ReQueueChannel)
	}
	if len(m.SequenceRange) > 0 {
		dAtA6 := make([]byte, len(m.SequenceRange)*10)
		var j5 int
		for _, num1 := range m.SequenceRange {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.RefTransactionId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefTransactionId)))
		i += copy(dAtA[i:], m.RefTransactionId)
	}
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0x62
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesDownstreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesDownstreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TransactionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.TransactionId)))
		i += copy(dAtA[i:], m.TransactionId)
	}
	if len(m.RefRequestId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefRequestId)))
		i += copy(dAtA[i:], m.RefRequestId)
	}
	if m.RequestTypeData != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RequestTypeData))
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x22
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsError {
		dAtA[i] = 0x28
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0x3a
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintKubemqGo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedPingResult(r randyKubemqGo, easy bool) *PingResult {
	this := &PingResult{}
	this.Host = string(randStringKubemqGo(r))
	this.Version = string(randStringKubemqGo(r))
	this.ServerStartTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ServerStartTime *= -1
	}
	this.ServerUpTimeSeconds = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ServerUpTimeSeconds *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedEmpty(r randyKubemqGo, easy bool) *Empty {
	this := &Empty{}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 1)
	}
	return this
}

func NewPopulatedResult(r randyKubemqGo, easy bool) *Result {
	this := &Result{}
	this.EventID = string(randStringKubemqGo(r))
	this.Sent = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 4)
	}
	return this
}

func NewPopulatedEvent(r randyKubemqGo, easy bool) *Event {
	this := &Event{}
	this.EventID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v1 := r.Intn(100)
	this.Body = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.Store = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v2 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v2; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 8)
	}
	return this
}

func NewPopulatedEventReceive(r randyKubemqGo, easy bool) *EventReceive {
	this := &EventReceive{}
	this.EventID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v3 := r.Intn(100)
	this.Body = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Sequence = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v4; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 8)
	}
	return this
}

func NewPopulatedSubscribe(r randyKubemqGo, easy bool) *Subscribe {
	this := &Subscribe{}
	this.SubscribeTypeData = Subscribe_SubscribeType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Group = string(randStringKubemqGo(r))
	this.EventsStoreTypeData = Subscribe_EventsStoreType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	this.EventsStoreTypeValue = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.EventsStoreTypeValue *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 7)
	}
	return this
}

func NewPopulatedRequest(r randyKubemqGo, easy bool) *Request {
	this := &Request{}
	this.RequestID = string(randStringKubemqGo(r))
	this.RequestTypeData = Request_RequestType([]int32{0, 1, 2}[r.Intn(3)])
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v5 := r.Intn(100)
	this.Body = make([]byte, v5)
	for i := 0; i < v5; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.ReplyChannel = string(randStringKubemqGo(r))
	this.Timeout = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Timeout *= -1
	}
	this.CacheKey = string(randStringKubemqGo(r))
	this.CacheTTL = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CacheTTL *= -1
	}
	v6 := r.Intn(100)
	this.Span = make([]byte, v6)
	for i := 0; i < v6; i++ {
		this.Span[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v7; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 13)
	}
	return this
}

func NewPopulatedResponse(r randyKubemqGo, easy bool) *Response {
	this := &Response{}
	this.ClientID = string(randStringKubemqGo(r))
	this.RequestID = string(randStringKubemqGo(r))
	this.ReplyChannel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v8 := r.Intn(100)
	this.Body = make([]byte, v8)
	for i := 0; i < v8; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.CacheHit = bool(bool(r.Intn(2) == 0))
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Executed = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	v9 := r.Intn(100)
	this.Span = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.Span[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v10 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v10; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 12)
	}
	return this
}

func NewPopulatedQueueMessage(r randyKubemqGo, easy bool) *QueueMessage {
	this := &QueueMessage{}
	this.MessageID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v11 := r.Intn(100)
	this.Body = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v12 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v12; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if r.Intn(10) != 0 {
		this.Attributes = NewPopulatedQueueMessageAttributes(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Policy = NewPopulatedQueueMessagePolicy(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 9)
	}
	return this
}

func NewPopulatedQueueMessagesBatchRequest(r randyKubemqGo, easy bool) *QueueMessagesBatchRequest {
	this := &QueueMessagesBatchRequest{}
	this.BatchID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v13)
		for i := 0; i < v13; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 3)
	}
	return this
}

func NewPopulatedQueueMessagesBatchResponse(r randyKubemqGo, easy bool) *QueueMessagesBatchResponse {
	this := &QueueMessagesBatchResponse{}
	this.BatchID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v14 := r.Intn(5)
		this.Results = make([]*SendQueueMessageResult, v14)
		for i := 0; i < v14; i++ {
			this.Results[i] = NewPopulatedSendQueueMessageResult(r, easy)
		}
	}
	this.HaveErrors = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 4)
	}
	return this
}

func NewPopulatedQueueMessageAttributes(r randyKubemqGo, easy bool) *QueueMessageAttributes {
	this := &QueueMessageAttributes{}
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Sequence = uint64(uint64(r.Uint32()))
	this.MD5OfBody = string(randStringKubemqGo(r))
	this.ReceiveCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ReceiveCount *= -1
	}
	this.ReRouted = bool(bool(r.Intn(2) == 0))
	this.ReRoutedFromQueue = string(randStringKubemqGo(r))
	this.ExpirationAt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ExpirationAt *= -1
	}
	this.DelayedTo = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.DelayedTo *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 9)
	}
	return this
}

func NewPopulatedQueueMessagePolicy(r randyKubemqGo, easy bool) *QueueMessagePolicy {
	this := &QueueMessagePolicy{}
	this.ExpirationSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ExpirationSeconds *= -1
	}
	this.DelaySeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.DelaySeconds *= -1
	}
	this.MaxReceiveCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MaxReceiveCount *= -1
	}
	this.MaxReceiveQueue = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedSendQueueMessageResult(r randyKubemqGo, easy bool) *SendQueueMessageResult {
	this := &SendQueueMessageResult{}
	this.MessageID = string(randStringKubemqGo(r))
	this.SentAt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SentAt *= -1
	}
	this.ExpirationAt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ExpirationAt *= -1
	}
	this.DelayedTo = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.DelayedTo *= -1
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 7)
	}
	return this
}

func NewPopulatedReceiveQueueMessagesRequest(r randyKubemqGo, easy bool) *ReceiveQueueMessagesRequest {
	this := &ReceiveQueueMessagesRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.MaxNumberOfMessages = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MaxNumberOfMessages *= -1
	}
	this.WaitTimeSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeSeconds *= -1
	}
	this.IsPeak = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 7)
	}
	return this
}

func NewPopulatedReceiveQueueMessagesResponse(r randyKubemqGo, easy bool) *ReceiveQueueMessagesResponse {
	this := &ReceiveQueueMessagesResponse{}
	this.RequestID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v15 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v15)
		for i := 0; i < v15; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	this.MessagesReceived = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MessagesReceived *= -1
	}
	this.MessagesExpired = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MessagesExpired *= -1
	}
	this.IsPeak = bool(bool(r.Intn(2) == 0))
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 8)
	}
	return this
}

func NewPopulatedAckAllQueueMessagesRequest(r randyKubemqGo, easy bool) *AckAllQueueMessagesRequest {
	this := &AckAllQueueMessagesRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.WaitTimeSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeSeconds *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedAckAllQueueMessagesResponse(r randyKubemqGo, easy bool) *AckAllQueueMessagesResponse {
	this := &AckAllQueueMessagesResponse{}
	this.RequestID = string(randStringKubemqGo(r))
	this.AffectedMessages = uint64(uint64(r.Uint32()))
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedStreamQueueMessagesRequest(r randyKubemqGo, easy bool) *StreamQueueMessagesRequest {
	this := &StreamQueueMessagesRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.StreamRequestTypeData = StreamRequestType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	this.Channel = string(randStringKubemqGo(r))
	this.VisibilitySeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.VisibilitySeconds *= -1
	}
	this.WaitTimeSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeSeconds *= -1
	}
	this.RefSequence = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		this.ModifiedMessage = NewPopulatedQueueMessage(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 9)
	}
	return this
}

func NewPopulatedStreamQueueMessagesResponse(r randyKubemqGo, easy bool) *StreamQueueMessagesResponse {
	this := &StreamQueueMessagesResponse{}
	this.RequestID = string(randStringKubemqGo(r))
	this.StreamRequestTypeData = StreamRequestType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	if r.Intn(10) != 0 {
		this.Message = NewPopulatedQueueMessage(r, easy)
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 6)
	}
	return this
}

func NewPopulatedQueuesUpstreamRequest(r randyKubemqGo, easy bool) *QueuesUpstreamRequest {
	this := &QueuesUpstreamRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v16)
		for i := 0; i < v16; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 3)
	}
	return this
}

func NewPopulatedQueuesUpstreamResponse(r randyKubemqGo, easy bool) *QueuesUpstreamResponse {
	this := &QueuesUpstreamResponse{}
	this.RefRequestID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v17 := r.Intn(5)
		this.Results = make([]*SendQueueMessageResult, v17)
		for i := 0; i < v17; i++ {
			this.Results[i] = NewPopulatedSendQueueMessageResult(r, easy)
		}
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedQueuesDownstreamRequest(r randyKubemqGo, easy bool) *QueuesDownstreamRequest {
	this := &QueuesDownstreamRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.RequestTypeData = QueuesDownstreamRequestType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}[r.Intn(10)])
	this.Channel = string(randStringKubemqGo(r))
	this.MaxItems = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MaxItems *= -1
	}
	this.WaitTimeout = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeout *= -1
	}
	this.AutoAck = bool(bool(r.Intn(2) == 0))
	this.ReQueueChannel = string(randStringKubemqGo(r))
	v18 := r.Intn(10)
	this.SequenceRange = make([]int64, v18)
	for i := 0; i < v18; i++ {
		this.SequenceRange[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.SequenceRange[i] *= -1
		}
	}
	this.RefTransactionId = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v19 := r.Intn(10)
		this.Metadata = make(map[string]string)
		for i := 0; i < v19; i++ {
			this.Metadata[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 13)
	}
	return this
}

func NewPopulatedQueuesDownstreamResponse(r randyKubemqGo, easy bool) *QueuesDownstreamResponse {
	this := &QueuesDownstreamResponse{}
	this.TransactionId = string(randStringKubemqGo(r))
	this.RefRequestId = string(randStringKubemqGo(r))
	this.RequestTypeData = QueuesDownstreamRequestType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}[r.Intn(10)])
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v20)
		for i := 0; i < v20; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v21 := r.Intn(10)
		this.Metadata = make(map[string]string)
		for i := 0; i < v21; i++ {
			this.Metadata[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 8)
	}
	return this
}

type randyKubemqGo interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneKubemqGo(r randyKubemqGo) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringKubemqGo(r randyKubemqGo) string {
	v22 := r.Intn(100)
	tmps := make([]rune, v22)
	for i := 0; i < v22; i++ {
		tmps[i] = randUTF8RuneKubemqGo(r)
	}
	return string(tmps)
}
func randUnrecognizedKubemqGo(r randyKubemqGo, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldKubemqGo(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldKubemqGo(dAtA []byte, r randyKubemqGo, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		v23 := r.Int63()
		if r.Intn(2) == 0 {
			v23 *= -1
		}
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(v23))
	case 1:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateKubemqGo(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *PingResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.ServerStartTime != 0 {
		n += 1 + sovKubemqGo(uint64(m.ServerStartTime))
	}
	if m.ServerUpTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.ServerUpTimeSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Sent {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Store {
		n += 2
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventReceive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.Sequence))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subscribe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubscribeTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.SubscribeTypeData))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.EventsStoreTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.EventsStoreTypeData))
	}
	if m.EventsStoreTypeValue != 0 {
		n += 1 + sovKubemqGo(uint64(m.EventsStoreTypeValue))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.RequestTypeData))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ReplyChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timeout))
	}
	l = len(m.CacheKey)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.CacheTTL != 0 {
		n += 1 + sovKubemqGo(uint64(m.CacheTTL))
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ReplyChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.CacheHit {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Executed {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MessageID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.Attributes != nil {
		l = m.Attributes.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessagesBatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessagesBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.HaveErrors {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessageAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.Sequence))
	}
	l = len(m.MD5OfBody)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.ReceiveCount != 0 {
		n += 1 + sovKubemqGo(uint64(m.ReceiveCount))
	}
	if m.ReRouted {
		n += 2
	}
	l = len(m.ReRoutedFromQueue)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.ExpirationAt != 0 {
		n += 1 + sovKubemqGo(uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		n += 1 + sovKubemqGo(uint64(m.DelayedTo))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessagePolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.ExpirationSeconds))
	}
	if m.DelaySeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.DelaySeconds))
	}
	if m.MaxReceiveCount != 0 {
		n += 1 + sovKubemqGo(uint64(m.MaxReceiveCount))
	}
	l = len(m.MaxReceiveQueue)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendQueueMessageResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MessageID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.SentAt != 0 {
		n += 1 + sovKubemqGo(uint64(m.SentAt))
	}
	if m.ExpirationAt != 0 {
		n += 1 + sovKubemqGo(uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		n += 1 + sovKubemqGo(uint64(m.DelayedTo))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReceiveQueueMessagesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.MaxNumberOfMessages != 0 {
		n += 1 + sovKubemqGo(uint64(m.MaxNumberOfMessages))
	}
	if m.WaitTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeSeconds))
	}
	if m.IsPeak {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReceiveQueueMessagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.MessagesReceived != 0 {
		n += 1 + sovKubemqGo(uint64(m.MessagesReceived))
	}
	if m.MessagesExpired != 0 {
		n += 1 + sovKubemqGo(uint64(m.MessagesExpired))
	}
	if m.IsPeak {
		n += 2
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AckAllQueueMessagesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.WaitTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AckAllQueueMessagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.AffectedMessages != 0 {
		n += 1 + sovKubemqGo(uint64(m.AffectedMessages))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamQueueMessagesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.StreamRequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.StreamRequestTypeData))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.VisibilitySeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.VisibilitySeconds))
	}
	if m.WaitTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeSeconds))
	}
	if m.RefSequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.RefSequence))
	}
	if m.ModifiedMessage != nil {
		l = m.ModifiedMessage.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamQueueMessagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.StreamRequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.StreamRequestTypeData))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesUpstreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesUpstreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RefRequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesDownstreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.RequestTypeData))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.MaxItems != 0 {
		n += 1 + sovKubemqGo(uint64(m.MaxItems))
	}
	if m.WaitTimeout != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeout))
	}
	if m.AutoAck {
		n += 2
	}
	l = len(m.ReQueueChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.SequenceRange) > 0 {
		l = 0
		for _, e := range m.SequenceRange {
			l += sovKubemqGo(uint64(e))
		}
		n += 1 + sovKubemqGo(uint64(l)) + l
	}
	l = len(m.RefTransactionId)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesDownstreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.RefRequestId)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.RequestTypeData))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovKubemqGo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozKubemqGo(x uint64) (n int) {
	return sovKubemqGo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *PingResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PingResult{`,
		`Host:` + fmt.Sprintf("%v", this.Host) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`ServerStartTime:` + fmt.Sprintf("%v", this.ServerStartTime) + `,`,
		`ServerUpTimeSeconds:` + fmt.Sprintf("%v", this.ServerUpTimeSeconds) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Result{`,
		`EventID:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`Sent:` + fmt.Sprintf("%v", this.Sent) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Event) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&Event{`,
		`EventID:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Store:` + fmt.Sprintf("%v", this.Store) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EventReceive) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&EventReceive{`,
		`EventID:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Sequence:` + fmt.Sprintf("%v", this.Sequence) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Subscribe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Subscribe{`,
		`SubscribeTypeData:` + fmt.Sprintf("%v", this.SubscribeTypeData) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Group:` + fmt.Sprintf("%v", this.Group) + `,`,
		`EventsStoreTypeData:` + fmt.Sprintf("%v", this.EventsStoreTypeData) + `,`,
		`EventsStoreTypeValue:` + fmt.Sprintf("%v", this.EventsStoreTypeValue) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&Request{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`RequestTypeData:` + fmt.Sprintf("%v", this.RequestTypeData) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`ReplyChannel:` + fmt.Sprintf("%v", this.ReplyChannel) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`CacheKey:` + fmt.Sprintf("%v", this.CacheKey) + `,`,
		`CacheTTL:` + fmt.Sprintf("%v", this.CacheTTL) + `,`,
		`Span:` + fmt.Sprintf("%v", this.Span) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Response) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&Response{`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ReplyChannel:` + fmt.Sprintf("%v", this.ReplyChannel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`CacheHit:` + fmt.Sprintf("%v", this.CacheHit) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Executed:` + fmt.Sprintf("%v", this.Executed) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`Span:` + fmt.Sprintf("%v", this.Span) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessage) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&QueueMessage{`,
		`MessageID:` + fmt.Sprintf("%v", this.MessageID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`Attributes:` + strings.Replace(fmt.Sprintf("%v", this.Attributes), "QueueMessageAttributes", "QueueMessageAttributes", 1) + `,`,
		`Policy:` + strings.Replace(fmt.Sprintf("%v", this.Policy), "QueueMessagePolicy", "QueueMessagePolicy", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessagesBatchRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessagesBatchRequest{`,
		`BatchID:` + fmt.Sprintf("%v", this.BatchID) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessagesBatchResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessagesBatchResponse{`,
		`BatchID:` + fmt.Sprintf("%v", this.BatchID) + `,`,
		`Results:` + strings.Replace(fmt.Sprintf("%v", this.Results), "SendQueueMessageResult", "SendQueueMessageResult", 1) + `,`,
		`HaveErrors:` + fmt.Sprintf("%v", this.HaveErrors) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessageAttributes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessageAttributes{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Sequence:` + fmt.Sprintf("%v", this.Sequence) + `,`,
		`MD5OfBody:` + fmt.Sprintf("%v", this.MD5OfBody) + `,`,
		`ReceiveCount:` + fmt.Sprintf("%v", this.ReceiveCount) + `,`,
		`ReRouted:` + fmt.Sprintf("%v", this.ReRouted) + `,`,
		`ReRoutedFromQueue:` + fmt.Sprintf("%v", this.ReRoutedFromQueue) + `,`,
		`ExpirationAt:` + fmt.Sprintf("%v", this.ExpirationAt) + `,`,
		`DelayedTo:` + fmt.Sprintf("%v", this.DelayedTo) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessagePolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessagePolicy{`,
		`ExpirationSeconds:` + fmt.Sprintf("%v", this.ExpirationSeconds) + `,`,
		`DelaySeconds:` + fmt.Sprintf("%v", this.DelaySeconds) + `,`,
		`MaxReceiveCount:` + fmt.Sprintf("%v", this.MaxReceiveCount) + `,`,
		`MaxReceiveQueue:` + fmt.Sprintf("%v", this.MaxReceiveQueue) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendQueueMessageResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendQueueMessageResult{`,
		`MessageID:` + fmt.Sprintf("%v", this.MessageID) + `,`,
		`SentAt:` + fmt.Sprintf("%v", this.SentAt) + `,`,
		`ExpirationAt:` + fmt.Sprintf("%v", this.ExpirationAt) + `,`,
		`DelayedTo:` + fmt.Sprintf("%v", this.DelayedTo) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReceiveQueueMessagesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReceiveQueueMessagesRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`MaxNumberOfMessages:` + fmt.Sprintf("%v", this.MaxNumberOfMessages) + `,`,
		`WaitTimeSeconds:` + fmt.Sprintf("%v", this.WaitTimeSeconds) + `,`,
		`IsPeak:` + fmt.Sprintf("%v", this.IsPeak) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReceiveQueueMessagesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReceiveQueueMessagesResponse{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`MessagesReceived:` + fmt.Sprintf("%v", this.MessagesReceived) + `,`,
		`MessagesExpired:` + fmt.Sprintf("%v", this.MessagesExpired) + `,`,
		`IsPeak:` + fmt.Sprintf("%v", this.IsPeak) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AckAllQueueMessagesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AckAllQueueMessagesRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`WaitTimeSeconds:` + fmt.Sprintf("%v", this.WaitTimeSeconds) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AckAllQueueMessagesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AckAllQueueMessagesResponse{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`AffectedMessages:` + fmt.Sprintf("%v", this.AffectedMessages) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamQueueMessagesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamQueueMessagesRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`StreamRequestTypeData:` + fmt.Sprintf("%v", this.StreamRequestTypeData) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`VisibilitySeconds:` + fmt.Sprintf("%v", this.VisibilitySeconds) + `,`,
		`WaitTimeSeconds:` + fmt.Sprintf("%v", this.WaitTimeSeconds) + `,`,
		`RefSequence:` + fmt.Sprintf("%v", this.RefSequence) + `,`,
		`ModifiedMessage:` + strings.Replace(fmt.Sprintf("%v", this.ModifiedMessage), "QueueMessage", "QueueMessage", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamQueueMessagesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamQueueMessagesResponse{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`StreamRequestTypeData:` + fmt.Sprintf("%v", this.StreamRequestTypeData) + `,`,
		`Message:` + strings.Replace(fmt.Sprintf("%v", this.Message), "QueueMessage", "QueueMessage", 1) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesUpstreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueuesUpstreamRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesUpstreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueuesUpstreamResponse{`,
		`RefRequestID:` + fmt.Sprintf("%v", this.RefRequestID) + `,`,
		`Results:` + strings.Replace(fmt.Sprintf("%v", this.Results), "SendQueueMessageResult", "SendQueueMessageResult", 1) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesDownstreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%v: %v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	s := strings.Join([]string{`&QueuesDownstreamRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`RequestTypeData:` + fmt.Sprintf("%v", this.RequestTypeData) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`MaxItems:` + fmt.Sprintf("%v", this.MaxItems) + `,`,
		`WaitTimeout:` + fmt.Sprintf("%v", this.WaitTimeout) + `,`,
		`AutoAck:` + fmt.Sprintf("%v", this.AutoAck) + `,`,
		`ReQueueChannel:` + fmt.Sprintf("%v", this.ReQueueChannel) + `,`,
		`SequenceRange:` + fmt.Sprintf("%v", this.SequenceRange) + `,`,
		`RefTransactionId:` + fmt.Sprintf("%v", this.RefTransactionId) + `,`,
		`Metadata:` + mapStringForMetadata + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesDownstreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%v: %v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	s := strings.Join([]string{`&QueuesDownstreamResponse{`,
		`TransactionId:` + fmt.Sprintf("%v", this.TransactionId) + `,`,
		`RefRequestId:` + fmt.Sprintf("%v", this.RefRequestId) + `,`,
		`RequestTypeData:` + fmt.Sprintf("%v", this.RequestTypeData) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`Metadata:` + mapStringForMetadata + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringKubemqGo(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *PingResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerStartTime", wireType)
			}
			m.ServerStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerStartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerUpTimeSeconds", wireType)
			}
			m.ServerUpTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerUpTimeSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sent = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Store = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReceive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReceive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReceive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscribe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscribe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscribe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscribeTypeData", wireType)
			}
			m.SubscribeTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscribeTypeData |= Subscribe_SubscribeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsStoreTypeData", wireType)
			}
			m.EventsStoreTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventsStoreTypeData |= Subscribe_EventsStoreType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsStoreTypeValue", wireType)
			}
			m.EventsStoreTypeValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventsStoreTypeValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeData", wireType)
			}
			m.RequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTypeData |= Request_RequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTTL", wireType)
			}
			m.CacheTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheTTL |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = append(m.Span[:0], dAtA[iNdEx:postIndex]...)
			if m.Span == nil {
				m.Span = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheHit = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Executed = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = append(m.Span[:0], dAtA[iNdEx:postIndex]...)
			if m.Span == nil {
				m.Span = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = &QueueMessageAttributes{}
			}
			if err := m.Attributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &QueueMessagePolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessagesBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessagesBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessagesBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessagesBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessagesBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessagesBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &SendQueueMessageResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveErrors", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HaveErrors = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessageAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessageAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessageAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MD5OfBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MD5OfBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveCount", wireType)
			}
			m.ReceiveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiveCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReRouted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReRouted = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReRoutedFromQueue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReRoutedFromQueue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationAt", wireType)
			}
			m.ExpirationAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayedTo", wireType)
			}
			m.DelayedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayedTo |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessagePolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessagePolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessagePolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationSeconds", wireType)
			}
			m.ExpirationSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelaySeconds", wireType)
			}
			m.DelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelaySeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReceiveCount", wireType)
			}
			m.MaxReceiveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReceiveCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReceiveQueue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxReceiveQueue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendQueueMessageResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendQueueMessageResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendQueueMessageResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentAt", wireType)
			}
			m.SentAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SentAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationAt", wireType)
			}
			m.ExpirationAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayedTo", wireType)
			}
			m.DelayedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayedTo |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveQueueMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveQueueMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveQueueMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumberOfMessages", wireType)
			}
			m.MaxNumberOfMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumberOfMessages |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeSeconds", wireType)
			}
			m.WaitTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPeak", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPeak = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveQueueMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveQueueMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveQueueMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessagesReceived", wireType)
			}
			m.MessagesReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessagesReceived |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessagesExpired", wireType)
			}
			m.MessagesExpired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessagesExpired |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPeak", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPeak = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AckAllQueueMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckAllQueueMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckAllQueueMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeSeconds", wireType)
			}
			m.WaitTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AckAllQueueMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckAllQueueMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckAllQueueMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedMessages", wireType)
			}
			m.AffectedMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedMessages |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamQueueMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamQueueMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamQueueMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamRequestTypeData", wireType)
			}
			m.StreamRequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamRequestTypeData |= StreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibilitySeconds", wireType)
			}
			m.VisibilitySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VisibilitySeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeSeconds", wireType)
			}
			m.WaitTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefSequence", wireType)
			}
			m.RefSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModifiedMessage == nil {
				m.ModifiedMessage = &QueueMessage{}
			}
			if err := m.ModifiedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamQueueMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamQueueMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamQueueMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamRequestTypeData", wireType)
			}
			m.StreamRequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamRequestTypeData |= StreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &QueueMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesUpstreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesUpstreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesUpstreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesUpstreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesUpstreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesUpstreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefRequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefRequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &SendQueueMessageResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesDownstreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesDownstreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesDownstreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeData", wireType)
			}
			m.RequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTypeData |= QueuesDownstreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			m.MaxItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItems |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeout", wireType)
			}
			m.WaitTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoAck = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReQueueChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReQueueChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SequenceRange = append(m.SequenceRange, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKubemqGo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthKubemqGo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SequenceRange) == 0 {
					m.SequenceRange = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SequenceRange = append(m.SequenceRange, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceRange", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefTransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefTransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesDownstreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesDownstreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesDownstreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefRequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefRequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeData", wireType)
			}
			m.RequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTypeData |= QueuesDownstreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKubemqGo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthKubemqGo
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthKubemqGo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipKubemqGo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthKubemqGo
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthKubemqGo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKubemqGo   = fmt.Errorf("proto: integer overflow")
)
